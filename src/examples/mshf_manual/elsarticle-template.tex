\documentclass[3p]{elsarticle}

\usepackage{lineno,hyperref}
\usepackage{graphicx}
\pdfoutput=1 
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{color}
\usepackage{subfigure}
\usepackage{url}
\usepackage{verbatim}
\usepackage{lipsum}
\usepackage{braket}
\usepackage{tcolorbox}
\modulolinenumbers[5]

\journal{Journal of \LaTeX\ Templates}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
%\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{The \textsc{MADNESS} Skyrme Hartree-Fock code \textsc{mshf}}

%% Group authors per affiliation:
\author{Authors}
\address{Affiliations}

\begin{abstract}
Manual abstract
\end{abstract}

%\begin{keyword}
%\texttt{elsarticle.cls}\sep \LaTeX\sep Elsevier \sep template
%\MSC[2010] 00-01\sep  99-00
%\end{keyword}

\end{frontmatter}

\linenumbers

\section{Introduction}
The code \textsc{mshf} code performs Hartree-Fock simulations of nuclear matter with a focus on ground states of nuclei and so-called nuclear pasta phases. The code is written using the Multi-resolution Adaptive Numerical Environment for Scientific Simulations (\textsc{MADNESS}).\\
Nuclear pasta phases are exotic shapes of nuclear matter that can form in the crust of neutron stars and during core-collapse supernovae. The presence of nuclear pasta in neutron star crusts can impact the stars' properties and observables such as thermal evolution, magnetic field, oscillations and deformations. In \textsc{mshf}, the ground state nuclear configuration is determined by finding the minimum binding energy of a system of proton and neutron single particle states in a given simulation volume. The nucleons are hereby subject to self-consistently determined nuclear and Coulomb mean-field potentials. \textsc{mshf} iteratively solves the Hartree-Fock equations of the nucleonic system using a Skyrme density functional. \\
In MADNESS, functions and operators are represented via multi-wavelets. MADNESS has built-in solvers for differential equations in many dimensions and for different boundary conditions. For references regarding MADNESS, see \cite{Harrison15, Harrison05, Harrison04, Fann10, Fann09}. For applications of MADNESS in density functional theory, see e.g. \cite{Pei12, Pei14}. For an example of other Skyrme Hartree-Fock simulation codes of nuclei and nuclear pasta phases see e.g. \cite{Maruhn14}.  \\
\textcolor{red}{Need an overview of MADNESS here and a bit more description about nuclear pasta in astrophysics. Also an overview of different methods to calculate nuclear pasta. Also a note on the justification of the code since there is an open source version of Sky3D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installing and Running}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \textsc{mshf} code consists of a main code file \texttt{mshf.cc} and two input files, \texttt{mshf\_input} and \texttt{mshf\_skyrme}. The first contains parameters for the simulation, e.g. simulation box size and boundary conditions. The second specifies the parameters of the Skyrme nuclear potential. \textsc{mshf} runs in the \textsc{MADNESS} numerical environment using its functions, operators and parallel runtime. The code files should be saved in the \textsc{MADNESS} example folder and the makefile modified by adding the \texttt{mshf} executable:\\
\texttt{bin\_PROGRAMS = hello \dots mshf}\\
\texttt{mshf\_SOURCES = mshf.cc}\\
Once \textsc{MADNESS} is built, the user can compile \textsc{mshf} by typing \texttt{make mshf}. When running the code, the input files \texttt{mshf\_input} and \texttt{mshf\_skyrme} should be in the same folder as the executable. Otherwise, \textsc{mshf} will run a simulation with default input and nuclear force parameters.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Skyrme Hartree-Fock Equations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textsc{mshf} iteratively solves the Hartree-Fock equations for a system consisting of $A$ nucleons:
\begin{align}
H_q \:  \psi_{i,q,s} (\vec{r}) = E_{i,q} \: \psi_{i,q,s} (\vec{r}),
\label{HFeq1}
\end{align}
with the Hamiltonian:
\begin{align}
H_q = -  \frac{\hbar^2}{2 m_q}  \: \Delta + U_{\mathrm{HF},q} (\vec{r})
\label{HFeq2}
\end{align}
where $\psi_{i,q,s}$ is a single particle state $i$ with mass $m_q$ and energy $E_{i,q}$. Each state has a spin $s$ (up $u$ or down $d$) and isospin $q$ (proton $p$ or neutron $n$). The nucleons are subjects to a mean-field potential $U_{\mathrm{HF},q}$ which depends on the states. To solve the above equations in \textsc{MADNESS}, we rewrite them into the Lippmann-Schwinger form:
\begin{align}
\left( k_q \: \Delta+ E_{i,q} \right) \psi_{i,q,s} (\vec{r}) &= U_{\mathrm{HF},q} (\vec{r}) \: \psi_{i,q,s} (\vec{r}), \\
 k_q & =  \frac{\hbar^2}{2 m_q} 
\end{align}
\begin{align}
&\psi_{i,q,s} (\vec{r}) = - \frac{1}{k_q} \: G_{\mathrm{BSH},i,q}  \star \left[ U_{\mathrm{HF},q} (\vec{r}) \: \psi_{i,q,s} (\vec{r}) \right] \\
&= - \frac{1}{k_q} \: \int_{-\infty}^{\infty} G_{\mathrm{BSH},i,q} (\vec{r}, \vec{s} ) \: \left[U_{\mathrm{HF},q} (\vec{s}) \: \psi_{i,q,s} (\vec{s})\right] \: d\vec{s} 
\label{conv1}
\end{align}
using the Green's function for the bound-state Helmholtz equation $G_{\mathrm{BSH},i,q}$:
\begin{align}
G_{\mathrm{BSH},i,q}  ( \vec{r} , \vec{s} ) = \frac{1}{ 4 \pi |\vec{r} - \vec{s}|} \: \exp\left(-\sqrt{ - \frac{E_{i,q} }{ k_q}} \: | \vec{r} - \vec{s} |\right)
\label{Greens}
\end{align}
The potential $U_{\mathrm{HF},q}$ is given by: 
\begin{align} 
U_{\mathrm{HF}, p} (\vec{r}) &= U_{p,\mathrm{sky}} (\vec{r}) + U_{p, \mathrm{meff}} (\vec{r}) + U_{p, so} (\vec{r}) \nonumber\\
& + U_{p, \mathrm{curr.}} (\vec{r}) + U_{p, \mathrm{spin}} (\vec{r}) \nonumber\\
&+ U_{C} (\vec{r}) + U_{C,ex} (\vec{r})
\label{Uprotons}
\end{align}
for protons and
\begin{align}
U_{\mathrm{HF}, n} (\vec{r}) &= U_{n,\mathrm{sky}} (\vec{r}) + U_{n, \mathrm{meff}}  (\vec{r}) + U_{n, so}  (\vec{r}) \nonumber\\
& + U_{n, \mathrm{curr.}}  (\vec{r}) + U_{n, \mathrm{spin}}  (\vec{r}) 
\label{Uneutrons}
\end{align}
for neutrons, respectively. The first component is a local nuclear potential whereas we use the Skyrme density functional:
\begin{align}
U_{q,\mathrm{sky}} (\vec{r}) &=  b_0 \rho (\vec{r}) - b^{\prime}_0 \rho_q (\vec{r}) + b_1 \tau (\vec{r}) - b^{\prime}_1 \tau_q (\vec{r}) \nonumber\\
&- b_2 \Delta \rho (\vec{r}) + b^{\prime}_2 \Delta \rho_q (\vec{r}) + b_3 \frac{\alpha+2}{3} \rho^{\alpha + 1}  (\vec{r}) \nonumber\\
&- b^{\prime}_3 \frac{2}{3} \rho^\alpha  (\vec{r}) \rho_q  (\vec{r}) - b^{\prime}_3 \frac{\alpha}{3} \rho^{\alpha - 1}  (\vec{r}) \left( \rho^2_n (\vec{r}) + \rho^2_p  (\vec{r}) \right) \nonumber\\
&- b_4 \nabla \cdot \vec{J}  (\vec{r}) - b_4^\prime \nabla \cdot \vec{J} _q   (\vec{r}),            
\label{Uskyrme}       
\end{align}
which is a sum of contributions from neutron and proton number densities $\rho_q$, kinetic densities $\tau_q$, and spin-orbit densities $\vec{J}_q$. The constants $b_j$ and $b^{\prime}_j$ ($j=0 \dots 4$) are parameters of the Skyrme potential and fitted to reproduce specific nuclear matter properties. The number densities $\rho_q$ and kinetic densities $\tau_q$ are calculated form the single particle states via: 
\begin{align}
\rho_q (\vec{r}) &= \sum\nolimits_{i}^{N_q} \left| \psi_{i,q,u} (\vec{r}) \right|^2 +  \left| \psi_{i,q,d} (\vec{r}) \right|^2 ,\\ 
\rho (\vec{r}) &= \rho_p (\vec{r})+ \rho_n (\vec{r}), \\
\tau_q (\vec{r}) &= \sum\nolimits_{i}^{N_q} \left| \nabla \psi_{q,i,u} (\vec{r}) \right|^2 +  \left| \nabla \psi_{q,i,d} (\vec{r}) \right|^2, \\ 
\tau(\vec{r}) &= \tau_p (\vec{r})+ \tau_n (\vec{r}),
\end{align}
with $N_q = Z$ for protons and $N_q = A-Z$ for neutrons where where $A$ is the mass number and $Z$ the charge number of the nuclear configuration. The divergence of the spin-orbit density $\vec{J}(\vec{r})$ is determined by:
\begin{align}
\nabla \cdot \vec{J}_q (\vec{r}) & = -\mathrm{i} \sum\nolimits_i^{N_q} \sum\nolimits_{s s^\prime} \nabla \psi_{i, q, s^\prime}^\star (\vec{r}) \nonumber\\
& \times \nabla \psi_{i,q,s} (\vec{r})  \cdot  \Braket{ s^\prime  | \vec{\sigma} | s} , 
\label{divJ}
\end{align}
where $\vec{\sigma} = (\sigma_x, \sigma_y, \sigma_z)^T$ is a vector of Pauli matrices. \\
For proton single-particle states, the Coulomb exchange potential $U_{C,\mathrm{ex}}$ in eq.(\ref{Uprotons}) is calculated via the so-called Slater approximation \cite{Chamel08}:
\begin{align}
U_\mathrm{C,ex} (\vec{r})= - \mathrm{e}^2 \left( \frac{3 \: \rho_p (\vec{r}) }{ \pi} \right)^{1/3}. 
\label{UCex}
\end{align}
The proton Coulomb potential is given by:
\begin{align}
U_{Cp} (\vec{r}) =  \mathrm{e}^2 \int \frac{ \: \rho_p (\vec{s})}{\left| \vec{r} - \vec{s} \right| } \: d \vec{s} . 
\label{UCp}
\end{align}
For periodic boundary conditions, we impose electric charge neutrality in the simulation volume by adding electrons. They are included via the so-called Jellium approximation, i.e. a homogeneous charge density $\rho_J = - Z/A$. As a consequence, in addition to the proton Coulomb potential we have to include the Coulomb potential of the Jellium:
\begin{equation}
U_{CJ} (\vec{r}) = \mathrm{e}^2 \int  \frac{\rho_J}{\left| \vec{r} - \vec{s} \right| } \: d \vec{s} .
\end{equation}
The sum of both contributions results in the total Coulomb potential: 
\begin{align}
U_C (\vec{r}) =  U_{Cp} (\vec{r}) + U_{CJ} (\vec{r}) =  \mathrm{e}^2 \int \frac{ \rho_C (\vec{s})}{\left| \vec{r} - \vec{s} \right| }  \: d\vec{s} , 
\end{align}  
where $\rho_C (\vec{r})= \rho_{p} (\vec{r})+ \rho_{J}$. Electron screening can be implemented via the following Green's function:
\begin{align}
G_{S,C} (\vec{r}) = \frac{1}{4 \pi r} \exp\left(-\frac{r}{\lambda}\right), 
\end{align}
with a screening length $\lambda$. The resulting screened proton Coulomb potential is then: 
\begin{align}
U_{S,Cp} (\vec{r}) = \frac{\mathrm{e}^2}{4 \pi}  \int \frac{ \: \rho_p (\vec{s})}{\left| \vec{r} - \vec{s} \right| } \: \exp\left(-\frac{\left| \vec{r} - \vec{s} \right|}{\lambda} \right)  \: d \vec{s}. 
\end{align}
The exchange potential is modified according to \cite{Mohammed84, Robinson62}:
\begin{align}
U_{S,ex} (\vec{r}) &= U_{ex} (\vec{r}) \: F(\alpha ), 
\label{Uscrex}\\
F(\alpha )& = 1 - \frac{4}{3} \alpha \tan^{-1} \left( \frac{2}{\alpha} \right) + \frac{1}{2} \alpha^2 \ln \left( 1 + 4 \alpha^{-2} \right) \\
&+ \frac{1}{6} \alpha^2 \left[ 1 - \frac{1}{4} \alpha^2 \ln ( 1 + 4 \alpha^{-2}) \right] , \\
 \alpha (\vec{r}) &= \left( \lambda \: k_F (\vec{r}) \right)^{-1}, \:\: k_F (\vec{r}) = \left(3 \pi^2 \rho_p (\vec{r}) \right)^{1/3} .
\label{Fgamma}
\end{align}
The remaining components of the nucleon potential in eq.(\ref{Uprotons}) and eq.(\ref{Uneutrons}) account for the density-dependent effective nucleon mass:
\begin{equation}
U_{q,\mathrm{meff}} (\vec{r}) =  - \nabla \cdot \left( b_1 \rho (\vec{r}) - b^{\prime}_1 \rho_q (\vec{r}) \right) \nabla
\label{Umeff}
\end{equation}
and the spin-orbit potential:
\begin{equation} 
U_{q,so} (\vec{r}) = \mathrm{i} \: \nabla W_q \cdot \left( \vec{\sigma} \times \nabla \right), \:\: W_q = b_4 \rho (\vec{r}) + b_4^\prime \rho_q (\vec{r}).
\label{Uso}
\end{equation}
For time-independent HF calculations of even-A and even-even nuclei and pasta phases we do not include the current and spin potentials $U_{q, \mathrm{curr.}}$ and $U_{q, \mathrm{spin}}$. The final potentials that are applied in the HF equations for protons and neutrons are:
\begin{align}
U_{\mathrm{HF},p} (\vec{r}) &=  U_{p,\mathrm{sky}}(\vec{r}) - \nabla \cdot \left( b_1 \rho (\vec{r}) - b^{\prime}_1 \rho_p (\vec{r}) \right) \nabla \nonumber\\
& + \mathrm{i} \: \vec{W}_p (\vec{r}) \cdot (\vec{\sigma} \times \nabla )+ U_{C}(\vec{r}) + U_{C,ex}(\vec{r}) , \\
U_{\mathrm{HF},n} (\vec{r}) &=  U_{n,\mathrm{sky}}(\vec{r}) - \nabla \cdot \left( b_1 \rho (\vec{r}) - b^{\prime}_1 \rho_n (\vec{r}) \right) \nabla \nonumber\\
&+ \mathrm{i} \: \vec{W}_n (\vec{r}) \cdot (\vec{\sigma} \times \nabla ).
\end{align}
The total binding energy of the system is calculated from the energy components of the Skyrme density functional: 
\begin{align}
E_0 &= \frac{1}{2} \int  b_0 \: \rho^2 (\vec{r}) - b^{\prime}_0 \left[ \rho_p^2 (\vec{r}) + \rho_n^2 (\vec{r}) \right] \: d \vec{r} , \\ 
E_1 &=  \int  b_1 \rho (\vec{r}) \tau (\vec{r}) - b^{\prime}_1 \left[\rho_p (\vec{r}) \tau_p (\vec{r}) + \rho_n (\vec{r}) \tau_n \right] \: d \vec{r} , 
\label{energy01}\\
E_2 &=  - \frac{1}{2} \int  b_2  \: \rho (\vec{r}) \Delta \rho (\vec{r}) \nonumber\\
& - b^{\prime}_2 \left[ \rho_p (\vec{r}) \Delta \rho_p + \rho_n (\vec{r}) \Delta \rho_n (\vec{r}) \right]   \: d \vec{r} , \\
E_3 &= \frac{1}{3} \int b_3 \: \rho^{\alpha + 2} (\vec{r}) - b^{\prime}_3 \: \rho^{\alpha} (\vec{r}) \left[ \rho_p^2 (\vec{r}) + \rho_n^2 (\vec{r}) \right]  \: d \vec{r} , 
\label{energy23}\\
E_4 &= - \int  b_4 \: \rho (\vec{r}) \: \nabla \vec{J} (\vec{r}) \nonumber\\
&+ b^{\prime}_4 \left[ \rho_q (\vec{r})  \: \nabla \vec{J}_p (\vec{r}) +  \rho_n (\vec{r})  \: \nabla \vec{J}_n (\vec{r}) \right] \:  d \vec{r} , 
\label{energy4}
\end{align}
as well as the kinetic, Coulomb and Coulomb exchange energies:
\begin{align}
E_\mathrm{kin} &= \sum\nolimits_{q} k_q \int  \tau_q(\vec{r}) \: d \vec{r}, 
\label{energy_kin}\\
E_{C} &= \frac{1}{2} \int U_C  (\vec{r}) \: \rho_p (\vec{r}) \: d \vec{r}, \\
E_{C,ex} &= - \frac{3}{4} \mathrm{e}^2 \left( \frac{3}{\pi} \right)^\frac{1}{3} \int \rho_p (\vec{r}) \: d \vec{r}.
\label{energy_coulomb_ex}
\end{align}
With that, the total energy and binding energy per nucleon are then given by:
\begin{align}
E_\mathrm{total} &= E_\mathrm{kin} + E_C + E_{C,ex} + E_0 + E_1 + E_2 \nonumber\\
& + E_3 + E_4, \:\:\: E_\mathrm{bind} = E_\mathrm{total} / \mathrm{A}, 
\label{energy_total}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iterative solution of the Skyrme Hartree-Fock equations}
\label{equations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We start out with a set of single particle states $\psi_{i,q,s}^{n}$ at iteration step $n=0$. The states are usually initialized either by harmonic oscillator states, plane waves, or Gaussians. 
After setting up the Hamiltonian $H_q$, the single particle states are orthogonalized and normalized by solving the generalized eigenvalue problem: 
\begin{align}
\tilde{H}_q \: C_q &= S_q \: C_q \: E_q , \nonumber\\
\tilde{H}_{q,ij} &= \int \psi_{i,q,u}^n (\vec{r})^\star \: H_q \: \psi_{j,q,u}^n (\vec{r}) \nonumber\\
&+ \psi_{i,q,d}^n (\vec{r})^\star \: H_q \: \psi_{j,q,d}^n (\vec{r}) \: d \vec{r}, \\
\tilde{S}_{q,ij} &= \int \psi_{i,q,u}^n (\vec{r})^\star\: \psi_{j,q,u}^n (\vec{r})  \nonumber\\
&+ \psi_{i,q,d}^n (\vec{r})^\star\: \psi_{j,q,d}^n (\vec{r}) \: d \vec{r} 
\label{SCE}
\end{align} 
for $C_q$ and $E_q$. In \textsc{MADNESS} this is done by using the LAPACK hermitian eigensolver. The new orthonormal single particle states $\tilde{\psi}_{i,q,s}^n$ with energies $E_{i,q}$ are obtained via
\begin{align}
\tilde{\psi}_{i,q,s}^n (\vec{r}) =  \sum\nolimits_{j}^{N_q} \psi_{j,q,s}^n (\vec{r}) \: C_{q,ij} .
\end{align}
In the same iteration step, the states are updated by applying $U_\mathrm{HF,q}$ and $G_\mathrm{BSH,i,q}$:
\begin{align}
\phi_{i,q,s}^{n+1} (\vec{r}) = - k_q^{-1} \: G_\mathrm{BSH,i,q} \star \: \left( U_\mathrm{HF,q} (\vec{r}) \: \tilde{\psi}_{i,q,s}^{n} (\vec{r}) \right).
\end{align} 
We then determine the maximum change among all single-particle states:  
\begin{align}
\delta \psi =& \mathrm{max} \{ \delta \psi_{0,p}, ..., \delta \psi_{N_p,p}, \delta \psi_{0,n}, ..., \delta \psi_{N_n,n} \},  \\
\delta \psi_{i,q}(\vec{r})   & = \sqrt{ \int \left| \delta \psi_{i,q,u} \right|^2 + \left| \delta \psi_{i,q,d} \right|^2} \\
\delta \psi_{i,q,s}(\vec{r}) &= \phi_{i,q,s}^{n+1} (\vec{r}) - \tilde{\psi}_{i,q,s}^{n} (\vec{r}) 
\label{convergence}
\end{align}
If $\delta \psi$ is smaller than or equal to a desired precision $\epsilon$, the calculation is considered converged. Otherwise, the new single-particle states are calculated by mixing the old and new states: 
\begin{align}
\psi_{i,q,s}^{n+1} (\vec{r}) = \chi \: \phi_{i,q,s}^{n+1} (\vec{r})+ (1 - \chi) \: \tilde{\psi}_{i,q,s}^{n} (\vec{r}), 
\label{chi}
\end{align} 
with $0 < \chi < 1$, typically $\chi = 0.4$. The new states are used to calculate an updated Hamiltonian and Green's functions and the above steps are repeated until $\delta \psi \leq \epsilon$.\\
To reduce numerical noise we apply Gaussian smoothing on $\Delta \rho_q$ by convolutions with:
\begin{align}
G_\mathrm{smooth} (\vec{r}) = \left( \frac{1}{\sqrt{2 \pi} \: b_r} \right)^{3} \: \exp\left(-\frac{r^2}{2 \: b_{r}^2}\right), 
\end{align}
where typically $b_{r} \sim 0.25\:$fm is chosen. Gaussian smoothing is used for $\Delta \rho_q$ and $\tau_q$ during the initial iterations. Once the calculations starts to converge smoothing is switched off for $\tau_q$. For $\Delta \rho_q$ it is replaced by mixing, similar to the mixing of single-particle states in eq.(\ref{chi}). 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Code Files and Routines}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Input files}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The {\tt mshf\_input} file contains parameters to initialize and run the simulation. They are categorized into general and nuclear parameters, mixing parameters, output and additional parameters and are listed in tables \ref{table1} - \ref{table5}.
\begin{table}
\caption{General parameters in file \texttt{mshf\_input}}
\begin{tabular*}{\columnwidth}{ l l l}
\hline
\hline
Variable & Description & Values\\
\hline
\texttt{A}                   & Mass number                                                    & \\
\texttt{Z}                   & Charge number                                                 & \\
\texttt{Box}               & Box length in fm                       & \\
\texttt{initial}             & Single particle                    & 1 = Gaussians\\
                                 & initialization                                                                          & 2 = Plane Waves\\
                                 &                                   			                  & 3 = Harm. Osc.\\
\texttt{boundary}       & Boundary conditions            & 0 = free space,\\          
				& 						                  & 1 = periodic\\                        
\texttt{knumber}        & Wavelet number                                                & \\
\texttt{thresh}            & Truncation threshold                                     & \\
\texttt{IO\_nodes}     & \# nodes for IO                                     & \\
\texttt{project}           & Projection switch                   & 1 = yes, else no \\
\hline
\hline
\end{tabular*}
\label{table1}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{General parameters:} These consist of the mass and charge number of the nuclear configuration {\tt A} and {\tt Z}, respectively. The code can handle up to several thousand nucleons. The problem size is usually dependent on the available memory and number of nodes. The {\tt Box} parameter gives the length of one box side (we assume a cubic simulations space) in fm. The boundary conditions are specified via {\tt periodic}. While {\sc MADNESS} provides a range of different boundary conditions, our code distinguishes between periodic and free space. The first are used for nuclear pasta calculations while the second are recommended for ground state calculations of isolated nuclei in a large simulation volume. The initialization of the single particle states is specified by the {\tt initial} parameter with values $1-3$. The wavelet number and truncation threshold are given by {\tt knumber} and {\tt thresh}, respectively. However, note that is the automatic projection switch {\tt project} is set to one, these are adjusted as the simulations converges by increasing {\tt knumber} and decreasing {\tt thresh} for better accuracy. For that, we follow the recommendation of {\sc MADNESS} via ... . Finally, {\sc MADNESS} allows parallel IO with a given number of nodes which we specify via the parameter {\tt IO\_nodes}.
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\caption{Nuclear parameters in file \texttt{mshf\_input}}
\begin{tabular*}{\columnwidth}{ l l l}
\hline
\hline
Variable & Description & Values\\
\hline
\texttt{jellium}              & Jellium switch                & 1 = yes, else no\\
\texttt{spinorbit}           & Spin-orbit switch                               & 1 = yes, else no\\
\texttt{meff}                  & Eff. mass switch                   & 1 = yes, else no\\
\texttt{screening}         & Electron screening                            & 1 = yes, else no\\
\texttt{screenl}             & Screen. length [fm]                         &  \\
\texttt{lap\_comp}         & Method for $\Delta \rho$                & 0 - 2 \\
\hline
\hline
\end{tabular*}
\label{table2}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Nuclear parameters:} The nuclear parameter sets contains information on whether the spin-orbit potential and the effective mass potential should be included. For ground state calculations of nuclei they should be included. For pasta simulations it sometimes makes sense to run tests without including both potentials since they significantly increase the simulation time. If {\tt spinorbit} and {\tt meff} are set to one, the spin-orbit potential and effective mass potential, respectively, are included. This parameter set also specifies how the Coulomb potential is calculated. If the simulation is done with periodic boundary conditions, then the jellium approximation must be applied. It includes a homogeneous background of electrons for overall charge neutrality. The jellium is included via the {\tt jellium} switch. Furthermore, we can include electron screening via the {\tt screening} switch. If the latter is switched on, the screening length must be given in femtometer via {\tt screenl}. Finally, we specify how the laplacian of the neutron and proton densities is calculated. We have three different methods which are described in section ... with their advantages and drawbacks. The method is specified by the parameter {\tt lap\_comp}.
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\caption{Mixing parameters in file \texttt{mshf\_input}}
\begin{tabular*}{\columnwidth}{ l l l}
\hline
\hline
Variable & Description & Values\\
\hline
{\tt avg\_pot}                & $U_{sky}$ mixing switch                   & 1 = yes, else no\\
\texttt{avg\_lap}           & $\Delta \rho_q$ mixing switch           & 1 = yes, else no\\
\texttt{avg\_wav}         & $\psi_i$ mixing switch                       & 1 = yes, else no\\
\texttt{chi}                    & Mixing parameter $\chi$                   & $\geq 0.5$ for stability \\ 
\hline
\hline
\end{tabular*}
\label{table3}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Mixing parameters: } These parameters set which quantities should be mixed between the old and the new iteration. We typically mix the single particle states throughout the entire simulation and the laplacian and kinetic densities while the simulation is converging and the nuclear configuration changing. However, we also provide the option to mix the Skyrme nuclear potential. The mixing parameter {\tt chi} gives the amount by which the old and new variables are mixed. 
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\caption{Output parameters in file \texttt{mshf\_input}}
\begin{tabular*}{\columnwidth}{ l l l}
\hline
\hline
Variable & Description & Values\\
\hline
\texttt{vtk\_output}       & vtk output switch                               & 1 = yes, else no\\
\texttt{txt\_output}        & txt output switch                               & 1 = yes, else no\\
\texttt{timing}               & Timing information                           & 1 = yes, else no\\
\hline
\hline
\end{tabular*}
\label{table4}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Output parameters:} There are two options for output. One gives .txt files for profiles along the x, y, and z axis for the total number density, the total kinetic density, the laplacian of the density and the potential. The created files are named accordingly. Alternatively or in addition to that, {\sc mshf} also gives output files in the vtk format that can be visualized by e.g. Paraview. For the latter there is one single file printed every defined number of iteration steps that contains the neutron, proton and total number densities, the kinetic density, the laplacian of the density and the Skyrme potential. To switch on the .txt or .vtk output the corresponding flags, {\tt vtk\_output} and {\tt txt\_output}, should be set to one. We also provide the option to print out timing information for different steps in the code. For that the {\tt timing} switch should be set to one.   
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\caption{Additional parameters}
\begin{tabular*}{\columnwidth}{ l l l}
\hline
\hline
Variable & Description & Values\\
\hline
\texttt{prec}                                & Add. precision factor                                           &\texttt{thresh*prec}\\
                                                  & for truncation                                                                                     & \\
\texttt{tol}                                   & for \texttt{BSH} and \texttt{Coulomb}                     & \\
\texttt{brad}                                & Smoothing radius                                                         & $\sim 0.25\:$fm; \\
& & if $<$ 0 smoothing is\\
                                                 &                                                                                                           & replaced by mixing \\                                           

\hline
\hline
\end{tabular*}
\label{table5}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Additional parameters}
%%%%%%%%%%%%%%%%%%%%%%%%%
Note that if the \texttt{project} parameter is set to 1, the wavelet number \texttt{knumber} and truncation threshold \texttt{thresh} are automatically adjusted for a higher accuracy as the simulation converges. The parameters are checkpointed and used at the restart of the simulation.
\paragraph{Skyrme parameters:} The \texttt{mshf\_skyrme} file contains the parameters $t_0 - t_4$, $x_0 - x_4$, $\alpha$, $k_{n}$ and $k_p$ which are used to calculate the $b$-parameters of the Skyrme potential via:
\begin{align}
b_0 &= t_0 \left( 1 + 0.5 \: x_0 \right), \:\: b^{\prime}_0 = t_0 \left( 0.5 + x_0 \right)\\
b_1 &= 0.25 \left[ t_1 \left( 1 + 0.5 \: x_1 \right) + t_2 \left( 1 + 0.5 \: x_2 \right) \right], \\
b^{\prime}_1 &= 0.25 \left[ t_1 \left( 0.5 + x_1 \right) - t_2 \left( 0.5 + x_2 \right) \right] \\ 
b_2 &= 0.125 \left[ 3\: t_1 \left( 1 + 0.5 \: x_1 \right) - t_2 \left( 1 + 0.5 \: x_2 \right) \right],\\ 
b^{\prime}_2 &= 0.125 \left[ 3 \: t_1 \left( 0.5 + x_1 \right) + t_2 \left( 0.5 + x_2 \right) \right] \\
b_3 &= 0.25 \: t_3 \left( 1 + 0.5 \: x_3 \right), \:\: b^{\prime}_3 = 0.25 \: t_3 \left( 0.5 + x_3 \right)\\
b_4 &= 0.5 \: t_4, \:\: b^{\prime}_4 = 0.5 \: t_4. 
\end{align}
The coefficient \texttt{alpha} is $\alpha$ in eq.(\ref{Uskyrme}), and \texttt{k\_fn} and \texttt{k\_fp} are
\begin{align}
k_{fn} = \hbar^2 / (2 \: m_n), \:\: k_{fp} = \hbar^2 / (2 \: m_p).
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code structure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The simulations are started out with the setup of the single particle states. These are either initialized from scratch or read-in from a checkpoint file. We then calculate the density terms, the local nuclear potential, the Coulomb and Coulomb exchange potentials. Together with the effective mass potential and the spin-orbit potential, the Hamiltonian is built. It is used to ortho-normalize the single particle states and update them via convolution with $G_{\mathrm{BSH},{i,q}}$. The old and the new states are compared to determine the maximum change in the wavefunctions \texttt{delta\_psi}. If the change is smaller than a defined mass number dependent threshold value but larger than the required precision for convergence we increase the wavelet number \texttt{knumber} and decrease the truncation threshold \texttt{thresh}. The the above iteration steps are then repeated. In computationally intensive parts of the iteration step, we perform MPI load balancing and for specified iterations write output files for plotting and checkpointing.\\
The main routine in the code is the \texttt{ground\_state} routine. It performs the following loop (the corresponding code routines are indicated by an arrow):
\begin{enumerate}
\item Initialization of single particle states. If checkpointing files exist, read states from the file and go to step 2, otherwise initialize states as Gaussians around point coordinates from an input file (\texttt{make\_MD}, \texttt{MD}), Harmonic Oscillator states (\texttt{make\_HO}, \texttt{HO}, \texttt{HOm}) or Plane waves (\texttt{make\_Fermi}, \texttt{Fermi}), all with spin up and spin down	
\item Print out iteration information (e.g. iteration number, wavelet number aso.) and check whether convergence criteria is fulfilled. If not proceed. 
\item Build local potential (\texttt{Potential})
	\begin{itemize}
		\item Calculate densities (via \texttt{ndensity}, \texttt{kdensity}, \texttt{so\_density}) and laplacian of the density (via \texttt{laplacian}, \texttt{laplacian1} or  \texttt{laplacian2})
		\item Determine kinetic energies of single particle states (\texttt{Kmatrix})
		\item Perform Gaussian smoothing for $\Delta \rho_q$ and $\tau_q$ terms, or mixing of $\Delta \rho_q$
		\item Calculate density terms with fractional power (\texttt{rho\_power})
		\item Determine Coulomb potential (\texttt{CoulombOperator}, \texttt{BSHOperator3D}) and the Coulomb exchange potential (\texttt{U\_ex}) 
		\item Assemble the local potential
		\item Calculate energies (\texttt{Energies}) and total binding energy (\texttt{Ebinding}) 
		\item Write output file for plotting (\texttt{output})
	\end{itemize}
\item Ortho-normalize and update single particle states (\texttt{iterate}):	
	\begin{itemize}
		\item Apply spin-orbit potential (\texttt{Uso}) and effective mass potential (\texttt{Umeff}) 
		\item Ortho-normalize states (\texttt{orthonorm}) 
		\item Build Green's functions $G_{\mathrm{BSH},i,q}$ (\texttt{BSHOperators}) and update ortho-normal states by convolution with $G_{\mathrm{BSH},i,q}$
		\item Calculate \texttt{delta\_psi} between old and new states
		\item Mix single particle states 
	\end{itemize}
\item If necessary, project to higher wavelet number and decrease truncation threshold
\item Create checkpoint files and go back to step 2
\end{enumerate} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{State initialization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
There are currently three different ways to initialize the nucleon single-particle states: 
\begin{enumerate}
	\item \textbf{\texttt{make\_MD}}, \textbf{\texttt{MD}}\\
	This routine sets up Gaussians  
	\begin{align}
	\psi_{i,q,s} (\vec{r}) &= \exp{\left(- \frac{1}{2 d^2} \left( \Delta n_x^2 + \Delta n_y^2 + \Delta n_z^2\right) \right)}, \\
	\Delta n_x &= x - N_x, \:\: \Delta n_y = y - N_y, \nonumber\\ 
	\Delta n_z &= z - N_z,  
	\end{align}
	of widths $d = 3\:$fm around given nucleon coordinates $(N_x, N_y, N_z)^T$ that should be provided in a separate input file as well as their 27 mirror images. This initialization can only be used with periodic boundary conditions. 
	\item  \textbf{\texttt{make\_HO}}, \textbf{\texttt{HO}}, \textbf{\texttt{HOm}}\\
	The routine \texttt{HOm} sets up modified Harmonic Oscillator states
	\begin{align}
	\psi_{i,q,s} (\vec{r}) &= x^{N_x} \: y^{N_y} \: z^{N_z} \nonumber\\
	 & \times \exp{\left[- \frac{1}{2} \left( \frac{x^2}{d_x^2} + \frac{y^2}{d_y^2} + \frac{z^2}{d_z^2} \right) \right]}, 
	\end{align}
	given a sequence of integers $N_x$, $N_y$ and $N_z$ and constant $d_x$, $d_y$, and $d_z$. In the routine \texttt{HO}, we set $d_x = d_y = d_z = d$. These initializations can be used with periodic and free-space boundary conditions.
	\item \textbf{\texttt{make\_Fermi}}, \textbf{\texttt{Fermi}}\\
	We initialize single-particle states as Plane Waves
	\begin{align}
	\psi_{i,q,s} (\vec{r}) &= \exp \left( \mathrm{i}  \: \vec{k} \cdot \vec{r} \right), \\ 
	k_j &= \pm \frac{2 \pi}{\lambda_j}, \:\:\: \lambda_i = \frac{2 L}{N_j}, \:\:\: j = x, y, z
	\end{align}
	with a sequence of integers $N_x$, $N_y$, and $N_z$. This initialization can be used with periodic and free-space boundary conditions, but we recommend to use periodic boundary conditions only.
\end{enumerate}
The neutron and proton states are initialized as vectors of functions and arranged into spin up and down states in the following way (the corresponding notation in the code for each vectors is given at the beginning of each line):
\begin{align}
 \texttt{psi\_nu}: \:\:\: \vec{\psi}_{n,u} (\vec{r}) &= \left( \psi_{1,n,u} (\vec{r}), \:  \dots,  \: \psi_{A-Z,n,u} (\vec{r}) \right)^T\\
 \texttt{psi\_nd}: \:\:\: \vec{\psi}_{n,d} (\vec{r}) &= \left( \psi_{1,n,d} (\vec{r}), \:  \dots,  \: \psi_{A-Z,n,d} (\vec{r}) \right)^T \\
\texttt{psi\_pu}: \:\:\: \vec{\psi}_{p,u} (\vec{r}) &= \left( \psi_{1,p,u} (\vec{r}), \:  \dots,  \: \psi_{Z,p,u} (\vec{r}) \right)^T \\
\texttt{psi\_pd}: \:\:\:  \vec{\psi}_{p,d} (\vec{r}) &= \left( \psi_{1,p,d} (\vec{r}), \:  \dots,  \: \psi_{Z,p,d} (\vec{r}) \right)^T 
\end{align}
For states that can be either protons or neutrons we usually use the notations \texttt{psi\_qu} and \texttt{psi\_ud}.   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simple manipulation of single particle states}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These routines manipulate existing single-particle states, e.g. normalization or truncation:
\begin{itemize}
\item \texttt{normalize\_2v}: Normalizes any two vectors of functions $\vec{\psi}_n$ (\texttt{psi\_n}) and $\vec{\psi}_p$ (\texttt{psi\_p}) by scaling each state with its L$_2$ norm:
\begin{align}
\vec{\psi}_{q} / | \vec{\psi}_q |, \: \: \: | \vec{\psi}_q | = \sqrt{\int | \vec{\psi}_q |^2 \: d \vec{r}}, \:\:\: q = n \:\:\mathrm{or} \:\:  p
\end{align}
\item \texttt{normalize\_ud}: Normalizes spin-up (\texttt{psi\_qu}) and down (\texttt{psi\_qd}) states via: 
\begin{align}
\psi_{i,q,s}  / \sqrt{ | \psi_{i,q,u} |^2 +  | \psi_{i,q,d} |^2 } , \: \: \: s = u \:\:\mathrm{or} \:\:  d
\end{align}
\item \texttt{spin\_split}: Splits a vector of single particle states $\vec{\psi}_q$ (\texttt{psi\_q}) into two vectors of functions of spin-up $\vec{\psi}_{q,u}$ (\texttt{psi\_qu}) and down $\vec{\psi}_{q,d}$ (\texttt{psi\_qd}) states 
\item \texttt{trunate1}, \texttt{truncate2}: Truncates one and two vectors of single particle states at the level \texttt{thresh*prec}. With free boundary conditions, we use truncation mode 1 while for periodic 
boundary conditions we use mode 0. 
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Densities}
\label{section::densities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These routines calculate various particle densities for the the Skyrme, Coulomb and Coulomb exchange potentials. Most of these routines are called in the \texttt{Potential} routine (see section \ref{section::potential}).
\begin{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{ndensity}: Calculates the number density of protons or neutrons using the single particle states $\psi_{q,u}$ (\texttt{psi\_qu}) and $\psi_{q,d}$ (\texttt{psi\_qd}):
\begin{align}
\rho_q = \sum\nolimits_i \left( | \psi_{i,q,u} |^2 +  | \psi_{i,q,d} |^2 \right) 
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{kdensity}: \textbf{intput}: Determines kinetic densities $\tau_q$ from partial derivatives of single particle states
\begin{align}
\tau_q &= \sum\nolimits_i \left( | \nabla \psi_{i,q,u} |^2  +  | \nabla \psi_{i,q,d} |^2 \right) 
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{laplacian}: Used when \texttt{lap\_comp = 0}. Calculates the laplacian of the number density in the usual way via:
\begin{align}
\Delta \rho_q = \frac{\partial^2}{\partial x^2} \rho_q + \frac{\partial^2}{\partial y^2} \rho_q + \frac{\partial^2}{\partial z^2} \rho_q .  
\label{lap_simple}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{laplacian1}: Used when \texttt{lap\_comp = 1}. Calculates the laplacian of the number density by the sum:
\begin{align}
\Delta \rho_q &= \Delta \sum\nolimits_i \left( \psi^{\star}_{i,q,u} \: \psi_{i,q,u} +  \psi^{\star}_{i,q,d} \: \psi_{i,q,d} \right) \nonumber\\
                      &= \nabla \cdot \sum\nolimits_i  \left( \nabla  \psi^{\star}_{i,q,u} \right) \psi_{i,q,u} +  \left( \nabla  \psi^{\star}_{i,q,d} \right) \psi_{i,q,d}  \nonumber\\
                      &+ \psi^{\star}_{i,q,u} \nabla \psi_{i,q,u} +  \psi^{\star}_{i,q,d} \nabla  \psi_{i,q,d}
\end{align}     
This takes longer than \texttt{laplacian}. However, the resulting function for $\Delta \rho_q$ seems to be less prone to numerical noise.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{laplacian2}: Used when \texttt{lap\_comp = 2}. Calculates the laplacian of the number density by the sum:
\begin{align}
\Delta \rho_q &= \Delta \sum\nolimits_i \left( \psi^{\star}_{i,q,u} \: \psi_{i,q,u} +  \psi^{\star}_{i,q,d} \: \psi_{i,q,d} \right) \\
&= \sum\nolimits_i   \psi_{i,q,u}  \Delta \psi^{\star}_{i,q,u} + 2 \nabla \psi^{\star}_{i,q,u} \cdot \nabla \psi_{i,q,u} \nonumber\\
                      &+ \psi^{\star}_{i,q,u}  \Delta \psi_{i,q,u} + \psi_{i,q,d}  \Delta \psi^{\star}_{i,q,d}  \nonumber\\
                      &+ 2 \nabla \psi^{\star}_{i,q,d} \cdot \nabla \psi_{i,q,d} + \psi^{\star}_{i,q,d}   \Delta \psi_{i,q,d}
\end{align}
This takes significantly longer than e.g. \texttt{laplacian}. However, the resulting $\Delta \rho_q$ seems to be less prone to numerical noise
\item \texttt{rho\_power}: Calculates the functions $\rho^\alpha$ for a given $\alpha$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{so\_density}: Calculates $\nabla \vec{J}_q$ according to:
\begin{align}
\nabla \vec{J}_q = -\mathrm{i} \sum\nolimits_i \sum\nolimits_{s s^\prime} \nabla \psi_{i(q,s^\prime)}^\star \times \nabla \psi_{i(q,s)} \cdot \Braket{ s^\prime  | \vec{\sigma} | s} .
\label{divJ}
\end{align}
The outer product for one state is:
\begin{align}
&\nabla \psi_{i,q,s^\prime}^\star \times \nabla \psi_{i,q,s} \nonumber\\
&= 
 \begin{pmatrix}
  \partial_y \psi_{i,q,s^\prime}^\star \: \partial_z \psi_{i,q,s} - \partial_y \psi_{i,q,s} \: \partial_z \psi_{i,q,s^\prime}^\star  \\
  \partial_z \psi_{i,q,s^\prime}^\star \: \partial_x \psi_{i,q,s} - \partial_z \psi_{i,q,s} \: \partial_x \psi_{i,q,s^\prime}^\star  \\
  \partial_x \psi_{i,q,s^\prime}^\star \: \partial_y \psi_{i,q,s} - \partial_z \psi_{i,q,s} \: \partial_y \psi_{i,q,s^\prime}^\star 
 \end{pmatrix}.
\end{align}
The spin eigenstates can either be spin-up $u = (1,0)^T$ or spin-down $d = (0,1)^T$. With the Pauli matrices
\begin{align}
\sigma_x & =  \begin{pmatrix} 0 & 1  \\ 1 & 0 \end{pmatrix}, \: \: \sigma_y =  \begin{pmatrix} 0 & -\mathrm{i}  \\ \mathrm{i} & 0 \end{pmatrix}, \nonumber\\ 
\sigma_z &=  \begin{pmatrix} 1 & 0  \\ 0 & -1 \end{pmatrix}, \vec{\sigma}  = (\sigma_x, \sigma_y, \sigma_z)^T \nonumber
\end{align}
 the different contributions to eq.(\ref{divJ}) can be calculated as:
\begin{align}
 \nabla \vec{J}_{i,q,uu}  &=  \nabla \psi_{i,q,u}^\star \times \nabla \psi_{i,q,d} \cdot \Braket{ u  | \vec{\sigma} | u } \\
&=   \partial_x \psi_{i,q,u}^\star \: \partial_y \psi_{i,q,u} - \partial_x \psi_{i,q,u} \: \partial_y \psi_{i,q,u}^\star  \label{12terms_i}\nonumber\\
\nabla \vec{J}_{i,q,dd} &= \nabla \psi_{i,q,d}^\star \times \nabla \psi_{i,q,d} \cdot \Braket{ d  | \vec{\sigma} | d } \\
& =  - \partial_x \psi_{i,q,d}^\star \: \partial_y \psi_{i,q,d} + \partial_x \psi_{i,q,d} \partial_y \psi_{i,q,d}^\star \nonumber\\
 \nabla \vec{J}_{i,q,ud} &= \nabla \psi_{i,q,u}^\star \times \nabla \psi_{i,q,d} \cdot \Braket{ u  | \vec{\sigma} | d } \\
&=  \partial_y \psi_{i,q,u}^\star \: \partial_z \psi_{i,q,d} - \partial_y \psi_{i,q,d} \: \partial_z \psi_{i,q,u}^\star  \nonumber\\
& - \mathrm{i} \partial_z  \psi_{i,q,u}^\star \partial_x \psi_{i,q,d} + \mathrm{i} \partial_z \psi_{i,q,d}  \partial_x  \psi_{i,q,u}^\star \nonumber\\
 \nabla \vec{J}_{i,q,du} &= \nabla \psi_{i,q,d}^\star \times \nabla \psi_{i,q,u} \cdot \Braket{ d  | \vec{\sigma} | u } \\
&=  \partial_y \psi_{i,q,d}^\star \: \partial_z \psi_{i,q,u} -  \partial_y \psi_{i,q,u} \: \partial_z \psi_{i,q,d}^\star \nonumber\\ 
& + \mathrm{i} \partial_z  \psi_{i,q,d}^\star \partial_x \psi_{i,q,u} - \mathrm{i} \partial_z \psi_{i,q,u} \partial_x  \psi_{i,q,d}^\star \nonumber
\label{12terms_f}
\end{align}
The final expression for the divergence of the spin-density is the sum:
\begin{align}
\nabla \vec{J}_q (\vec{r}) &=  \sum\nolimits_i  \nabla \vec{J}_{i,q, uu} (\vec{r}) + \nabla \vec{J}_{i,q, d u} (\vec{r}) \nonumber\\
&+ \nabla \vec{J}_{i,q, u d} (\vec{r}) + \nabla \vec{J}_{i,q, d d}  (\vec{r})  .
\end{align}
It consists of the 12 terms in equations (\ref{12terms_i}) - (\ref{12terms_f}). The subroutine \texttt{so\_densities} calculates and sums these terms for the proton and neutron states.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Potentials}
\label{section::potential}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
With the various calculated density terms we setup the Skyrme nuclear mean-field potential in the routine \texttt{Potential} together with the Coulomb and Coulomb exchange potentials. The \texttt{Potential} routine also performs Gaussian smoothing of $\Delta \rho_q$ and $\tau_q$ or mixing of $\Delta \rho_q$ between the current and previous iteration. Summing up all density terms, $U_{q,\mathrm{sky}}$ is assembled. The binding energies and all energy terms are calculated via the \texttt{Ebinding} and \texttt{Energies} for output information followed by plotting data in the \texttt{output} routine. Some potential routines that are applied in \texttt{Potential} are:
\begin{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{uex}: Calculates the Coulomb exchange potential \texttt{U\_{ex}} from the proton density. We first determine 
\begin{align}
U = - \left( 3 / \pi \right)^{1/3} \rho_p^{-2/3}
\end{align}
and then multiply by $\rho_p$ and the elementary charge $\mathrm{e}^2 = 1.43989\:\:$MeV$\:$fm:
\begin{align}
U_{C,ex} = - \mathrm{e}^2 \left(3 / \pi \right)^{1/3} \rho_p^{1/3}.
\end{align}
\item \texttt{Fgamma}: Returns the modification function $F(\alpha)$ for the screened exchange potential in eq.(\ref{Uscrex}) and eq.(\ref{Fgamma}). 
\end{itemize}
The effective mass and spin-orbit potential are calculated in the \texttt{iterate} routine. In fact, instead of just calculating the potentials, we determine the products $U_{\mathrm{meff},q,s} \: \vec{\psi}_{q,s}$ and $U_{so} \: \vec{\psi}_{q,u}$ that are represented by vectors of functions in the the code. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \texttt{Umeff}: Applies the effective mass potential on single particle state: 
\begin{align}
U_{\mathrm{meff},q,s}   \: \vec{\psi}_{q,s}  & = - \nabla \cdot \left( \: B_q \: \nabla \vec{\psi}_{q,s} \: \right) \\
& = - \partial_x \left( B_q \: \partial_x \vec{\psi}_{q,s} \right) - \partial_y \left( B_q \: \partial_y \vec{\psi}_{q,s} \right) \nonumber\\
&- \partial_z \left( B_q \: \partial_z \vec{\psi}_{q,s} \right) \\
B_q = b_1 \rho - b_1^\prime \rho_q 
\label{Umeff_u}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{Uso}: Calculates and applies the spin-orbit potential on the proton and neutron single-particle states:
\begin{align}
U_{q,so} \: \begin{pmatrix} \vec{\psi}_{q,u} \\ \vec{\psi}_{q,d} \end{pmatrix} &= \mathrm{i} \: \left( \nabla \: W_q \right)  ( \vec{\sigma} \times \vec{\nabla} ) \: \begin{pmatrix} \vec{\psi}_{q,u} \\ \vec{\psi}_{q,d} \end{pmatrix}, \\
 W_q &= b_4 \rho + b_4^\prime \rho_q  
\end{align}
The outer product between the Pauli matrices and the nabla operator gives 
\begin{align}
 \vec{\sigma} \times  \vec{\nabla}  =  \begin{pmatrix} \sigma_x \\ \sigma_y \\ \sigma_z \end{pmatrix} \times \begin{pmatrix} \partial_x \\ \partial_y \\ \partial_z \end{pmatrix} = \begin{pmatrix} \sigma_y \partial_z -\sigma_z \partial_y \\ \sigma_z \partial_x - \sigma_x \partial_z \\ \sigma_x \partial_y - \sigma_y \partial_x \end{pmatrix} 
\end{align}
resulting in
\begin{align}
&\left( \nabla \:W_q \right) ( \vec{\sigma} \times  \vec{\nabla} ) =   \begin{pmatrix} \partial_x W_q \\ \partial_y W_q \\ \partial_z W_q \end{pmatrix}  \begin{pmatrix} \sigma_y \partial_z -\sigma_z \partial_y \\ \sigma_z \partial_x - \sigma_x \partial_z \\ \sigma_x \partial_y - \sigma_y \partial_x \end{pmatrix} \\
\newline \nonumber\\
&=  (\partial_x W_q) \left( \sigma_y \partial_z - \sigma_z \partial_y \right) + (\partial_y W_q) \left( \sigma_z \partial_x - \sigma_x \partial_z \right) \nonumber\\
&+  (\partial_z W_q) \left( \sigma_x \partial_y - \sigma_y \partial_x \right) .
\end{align}
With that:
\begin{align}
U_{q,so} \: \vec{\psi}_{q,u} & = \left[ - \mathrm{i} (\partial_x W_q) \: \partial_y + \mathrm{i} (\partial_y W_q) \: \partial_x \right] \vec{\psi}_{q,u} \nonumber\\
&+ \left[ (\partial_x W_q) \: \partial_z  - \mathrm{i} (\partial_y W_q) \: \partial_z \right] \vec{\psi}_{q,d} \nonumber\\
&+ \left[ \mathrm{i} (\partial_z W_q) \: \partial_y - (\partial_z W_q) \: \partial_x \right] \vec{\psi}_{q,d}  
\label{Uso1}\\
U_{q,so} \: \vec{\psi}_{q,d} & = \left[ - (\partial_x W_q) \: \partial_z - \mathrm{i} (\partial_y W_q) \: \partial_z \right] \vec{\psi}_{q,u} \nonumber\\
&+ \left[ \mathrm{i} (\partial_z W_q) \: \partial_y + (\partial_z W_q) \: \partial_x \right] \vec{\psi}_{q,u} \nonumber\\
&+ \left[ \mathrm{i} (\partial_x W_q) \: \partial_y - \mathrm{i} (\partial_y W_q) \: \partial_x \right] \vec{\psi}_{q,d}
\label{Uso2}
\end{align}
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iteration of single particle states}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These routines change/update the single particle states. Examples are convolutions with Green's function for the bound-state Helmholtz equation or orthonormalization.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \texttt{iterate}: Ortho-normalizes the single particle states and updates them by applying the convolution with $G_{\mathrm{BSH},i(q)}$.
First, we create vectors of functions for $U_\mathrm{q,sky} \: \vec{\psi}_{q,s}$ (\texttt{Upsi\_qu} and \texttt{Upsi\_qd}) by performing the corresponding of the potential with the single particle states.  After that, we update \texttt{Upsi\_qu} and \texttt{Upsi\_qd} by adding the contribution from the spin-orbit potential $U_\mathrm{q, so} \: \vec{\psi}_{q,s}$ (see \texttt{Uso}) and the effective mass potential term  $U_\mathrm{q, meff} \: \vec{\psi}_{q,s}$ (see \texttt{Umeff}).\\ 
The single particle states are ortho-normalized in the \texttt{orthonorm} routine which also returns the energies of the single particle states. These are used to set up the Green's functions $\vec{G}_{\mathrm{BSH}, i, q}$ in the \texttt{BSHoperators} routine, which are used to update \texttt{phi\_qu} and \texttt{phi\_qd} via convolutions of the Green's functions with \texttt{Upsi\_qu} and \texttt{Upsi\_qd}. The new states are normalized and compared to \texttt{psi\_qu} and \texttt{psi\_qd}. The maximum change in the single particle states \texttt{delta\_psi} is determined. After that, \texttt{phi\_qu} and \texttt{phi\_qd} are mixed with \texttt{psi\_qu} and \texttt{psi\_qd} using the mixing parameter \texttt{chi}. The resulting updated single particle states are again normalized. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{orthonorm}: This routine ortho-normalizes the single particle states. The Hamiltonian matrix \texttt{H\_q} from eq.(\ref{SCE}) is formed by first calculating the kinetic matrix \texttt{K\_q} via \texttt{Kmatrix} and then adding the inner products of the single particle states with \texttt{Upsi\_qu} and \texttt{Upsi\_qd}. The overlap matrix \texttt{S\_q} is calculated as inner products of the single particle states (see eq.(\ref{SCE})). We then use the built-in lapack routine to solve the eigenvalue problem for the single particle states \texttt{psi\_qu} and \texttt{psi\_qd}.\\
If neither spin-orbit potentials nor effective mass potentials are included, we only ortho-normalize the single-particle states and then simply multiply them by the local nuclear potentials. The solution of the eigenvalue problem also provides the energies of the ortho-normal single particle states.\\
Especially in the beginning of the iterations, it can happen that the energy of a state is positive. This will lead to problems when setting up the BSH Green's functions since these are only defined for negative energies. The problem can be solved via scaling the energies of the single particle states by a constant value \texttt{Es}. The reduction of the energy has to be done consistently for the built of the Green's functions and also by scaling \texttt{Upsi\_qu} and \texttt{Upsi\_qd}.\\
The scaling energy is determined in the \texttt{orthonorm} routine in each iteration. We have a minimal default value for \texttt{Es} but replace it with twice the maximum energy of the single-particle states in case the latter is larger than the default value. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{Kmatrix}: Calculates matrix of kinetic energies of the single particle states:
\begin{align}
K_{ij,q} = - k_q \left( \int \psi_{i,q,u} \nabla^2 \psi_{j,q,u} + \int  \psi_{i,q,d}  \nabla^2 \psi_{j,q,d} \right).
\end{align} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{BSHoperators}: Creates a vector of $\vec{G}_\mathrm{BSH}$ for scaled single particle state energies:
\begin{align}
G_{\mathrm{BSH},i,q} ( \vec{r} , \vec{s} ) &= \frac{1}{ 4 \pi |\vec{r} - \vec{s}|} \exp\left( - \kappa_{i,q} \: | \vec{r} - \vec{s} |\right) , \\
 \kappa_{i,q} &= \sqrt{ - \frac{E_{i,q} - E_s}{k_q}}.
\end{align}
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
There are different output files in the code. These include plotting files in vtk (\texttt{paraview\_\#iter.vts}) and csv (\texttt{densities\_\#iter.txt}, \texttt{potential\_\#iter.txt}) formats for potential and density profiles at iteration \texttt{iter}, and a log file (\texttt{log.txt}) for \texttt{maxerr}, \texttt{BE} aso. for each iteration step. The  file \texttt{En\_\#iter.txt} contains information about the energy terms of the Skyrme density functional and energies of the single particle states. \\
The plotting and energy files are created in the \texttt{output} and \texttt{Ebinding} routines, respectively. The \texttt{log.txt} file is created and updated in the \texttt{doit} routine.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \texttt{Energies}: Creates an output file with the single particle state energies. First, the matrix of kinetic energies is created in the \texttt{Potential} routine. The \texttt{Energies} routine uses the kinetic energies and the matrix of total single particle state energies to write an output file with a table that contains:
\begin{enumerate}
\item The number of the single particle state
\item The kinetic energy of the state
\item The potential energy of the state (as difference between total and kinetic energies)
\item The total energy of the state
\end{enumerate}
In the zeroth iteration, we calculate the potential energy as inner products 
\begin{align}
E_{i,q} = \int \psi_{i,q,u} \: U_\mathrm{q,sky} \:  \psi_{i, q, u} + \int \psi_{i, q, d} \: U_\mathrm{q,sky} \: \psi_{i,q,d}
\end{align}
and calculate the total energy as a sum of the kinetic and potential contributions. If the \texttt{En\_\#iter.txt} file has already been created in the \texttt{Ebinding} routine, the \texttt{Energies} routine appends the single particle state energies to this file.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item \texttt{Ebinding}: Calculates the five Skyrme Energy terms (see eq.(\ref{energy01}) - eq.(\ref{energy4})), the Coulomb and Coulomb exchange energies (see eq.(\ref{energy_coulomb_ex})) and the total kinetic energy (see eq.(\ref{energy_kin})). As in eq.(\ref{energy_total}), It adds all contributions to calculate the total binding energy per baryon. The routine writes out an energy file \texttt{En\_\#iter.txt} containing the energy contributions. 
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}
\subsection{Relaxation of puren neutron matter}
\subsection{Relaxation of isospin symmetric nuclear matter at saturation density}
\subsection{Nuclear ground states for O$^{16}$, Pb$^{208}$, U$^{238}$, Mo$^{110}$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{References}

\bibliography{ref}

\end{document}