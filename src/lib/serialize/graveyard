            
            static
            typename madness::enable_if_c<Archive::is_output_archive, Archive&>
            wrap_acdc (Archive& ar, const T& t) {
                MAD_ARCHIVE_DEBUG(std::cout << "wrap_acdc for default output" << std::endl);
                ar << t;
            };
            
            static
            typename madness::enable_if_c<Archive::is_input_archive, Archive&>
            wrap_acdc (Archive& ar, const T& t) {
                MAD_ARCHIVE_DEBUG(std::cout << "wrap_acdc for default input" << std::endl);
                ar >> t;
            };



    
    /// Preamble for output text (XML) archive
    template <class T>
    void preamble(TextFstreamOutputArchive& ar, const T& dummy) {
      ar.store_start_tag<T>();
    }
    
    
    /// Postamble for output text (XML) archive
    template <class T>
    void postamble(TextFstreamOutputArchive& ar, const T& dummy) {
      ar.store_end_tag<T>();
    }



        /// Redirect \c load(ar,t) for fundamental types to \c ar.load(&t,1)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< madness::is_fundamental<T>::value, 
                                                          Archive::is_input_archive >, 
                                     void >::type
        load(Archive& ar, T& t) {
            MAD_ARCHIVE_DEBUG(std::cout << "load(ar,t) fund" << std::endl);
            ar.load(&t,1);
        }
        
        
        /// Redirect \c load(ar,t) for non-fundamental types to \c serialize(ar,t)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< !madness::is_fundamental<T>::value, 
                                                          Archive::is_input_archive >, 
                                     void >::type
        load(Archive& ar, T& t) {
            
        }



        
        
        /// Redirect \c load(ar,t) for fundamental types to \c ar.load(&t,1)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< madness::is_fundamental<T>::value, 
                                                          Archive::is_input_archive >, 
                                     void >::type
        load(Archive& ar, T& t) {
            MAD_ARCHIVE_DEBUG(std::cout << "load(ar,t) fund" << std::endl);
            ar.load(&t,1);
        }
        
        
        /// Redirect \c load(ar,t) for non-fundamental types to \c serialize(ar,t)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< !madness::is_fundamental<T>::value, 
                                                          Archive::is_input_archive >, 
                                     void >::type
        load(Archive& ar, T& t) {
            
        }
        
        
        /// Redirect \c store(ar,t) for fundamental types to \c ar.store(&t,1)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< madness::is_fundamental<T>::value, 
                                                          Archive::is_output_archive >, 
                                     void >::type
        store(Archive& ar, const T& t) {
            MAD_ARCHIVE_DEBUG(std::cout << "store(ar,t) fund" << std::endl);
            ar.store(&t,1);
        }
        
        
        /// Redirect \c store(ar,t) for non-fundamental types to \c serialize(ar,t)
        template <class Archive, class T>
        inline
        typename madness::enable_if< madness::type_and_c< !madness::is_fundamental<T>::value, 
                                                          Archive::is_output_archive >, 
                                     void >::type
        store(Archive& ar, const T& t) {
            MAD_ARCHIVE_DEBUG(std::cout << "store(ar,t) non-fund" << std::endl);
            serialize(ar,t);
        }
        


        /// Foulness required (???) to lose constness when serializing
        template <class Archive, class T>
        inline
        typename madness::enable_if_c< Archive::is_archive, void >::type
        serialize(Archive& ar, const T& t) {
            MAD_ARCHIVE_DEBUG(std::cout << "losing const in serialize(ar,t)" << std::endl);
            serialize(ar, (T&) t);
        }





        template <class Archive, class T> struct ArchiveImpl;
        template <class Archive, class T> struct ArchivePrePostImpl;
        template <class Archive, class T> struct ArchiveLoadImpl;
        template <class Archive, class T> struct ArchiveStoreImpl;
        template <class Archive, class T> struct ArchiveSerializeImpl;
        
