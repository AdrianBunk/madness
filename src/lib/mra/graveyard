//         /// Returns vector of keys of all local nodes where predicate is true
//         template <typename predicateT>
//         std::vector<keyT> keys (const predicateT& predicate) {
//             std::vector<keyT> v;
//             v.reserve(this->size());
//             for (typename implT::iterator it = this->begin(); it != this->end(); ++it) {
//                 if (predicate(*it)) v.push_back(it->first);
//             }
//             return v;
//         };

//         /// Returns vector of keys of all local nodes
//         std::vector<keyT> keys () {
//             return keys(true_predicate<datumT>());
//         };


//         /// Returns vector of keys of local leaf nodes
//         std::vector<keyT> leaf_nodes () {
//             return keys(is_leaf_predicate());
//         };


//         /// Returns vector of keys of all local nodes with coeff
//         std::vector<keyT> coeff_nodes () {
//             return keys(has_coeff_predicate());
//         };


        struct true_predicate {
            bool operator()(const datumT& d) const {
                return true;
            };
        };
        

        struct is_leaf_predicate {
            bool operator()(const datumT& d) const {
                return d.second.is_leaf();
            };
        };

        struct is_not_leaf_predicate {
            bool operator()(const datumT& d) const {
                return !d.second.is_leaf();
            };
        };

        struct  has_coeff_predicate {
            bool operator()(const datumT& d) const {
                return d.second.has_coeff();
            };
        };

        struct  has_no_coeff_predicate {
            bool operator()(const datumT& d) const {
                return !d.second.has_coeff();
            };
        };



//         void insert_weird_tree(const keyT& key) {
// //       for (Level i = 0; i < key.level(); i++) cout << "  ";
// //       print(key);
//          Level Nmax = 1;
//          if (is_local(key)) {
//              bool has_children = ((key.level() < Nmax) || ((key.level() < 2*Nmax)&&
//                      (key.translation()[0] == key.translation()[NDIM-1])));
//              FunctionNode<T,NDIM> node(tensorT(0), has_children);
//              this->insert(key,node);
//              if (has_children) {
//                     for (KeyChildIterator<NDIM> kit(key); kit; ++kit) {
//                      insert_weird_tree(kit.key());
//                     }
//              }
//          }
//          else if (key.level() < Nmax) {
//              for (KeyChildIterator<NDIM> kit(key); kit; ++kit) {
//                  insert_weird_tree(kit.key());
//              }
//          }
//         };


        /// Optimized filter (inplace, contiguous, no err checking)

        /// Transforms coefficients in s returning result also in s.
        /// Uses work2 from common data to eliminate temporary creation and
        /// to increase cache locality.
        ///
        /// No communication involved.
//         inline void filter_inplace(tensorT& s) {
//             transform_inplace(s, cdata.hgT, cdata.work2);
//         };


        /// Optimized unfilter (see info about filter_inplace)

        /// No communication involved.
//         inline void unfilter_inplace(tensorT& s) {
//             transform_inplace(s, cdata.hg, cdata.work2);
//         };
#define WORLD_INSTANTIATE_STATIC_TEMPLATES
#include <mra/loadbal.h>

using namespace std;

namespace madness {

    typedef int Cost;
    typedef double CompCost;

    template <typename T, int D>
    vector<typename DClass<D>::TreeCoords> LoadBalImpl<T,D>::findBestPartition() {
        vector<typename DClass<D>::TreeCoords> klist;
        if (this->f.impl->world.mpi.rank() != 0) {
            print("findBestPartition: leave it to the expert");
            this->f.impl->world.gop.fence();
            print("about to do broadcast");
            unsigned int ksize;
            this->f.impl->world.gop.template broadcast<unsigned int>(ksize);
            for (unsigned int i = 0; i < ksize; i++) {
                typename DClass<D>::TreeCoords t;
                this->f.impl->world.gop.template broadcast<typename DClass<D>::TreeCoords>(t);
                klist.push_back(t);
            }
            print("done with broadcast");
            return klist;
        }
        unsigned int npieces = this->f.impl->world.nproc();
        bool notdone = true;
        int count = 0;
        vector<vector<typename DClass<D>::TreeCoords> > listoflist;
        vector<typename DClass<D>::TreeCoords> emptylist;
        vector<Cost> costlist;

        listoflist.push_back(emptylist);
        costlist.push_back(0);
        Cost totalCost = 0;

<<<<<<< .mine
        madness::print("findBestPartition: about to fixCost");
=======
//madness::print("findBestPartition: about to fixCost");
>>>>>>> .r223

<<<<<<< .mine
        typename DClass<D>::KeyD root(0);
        this->skeltree->template fixCost(root);
        madness::print("findBestPartition: about to depthFirstPartition");
        //    this->skeltree->print(root);
        totalCost = this->skeltree->template depthFirstPartition(root, &listoflist[count], npieces,
                    totalCost, &costlist[count]);
        //madness::print("findBestPartition: after depthFirstPartition");
        int size = listoflist[count].size();
        cout << "Partitioned tree " << count << ":" << endl;
        for (int i = 0; i < size; i++)
            listoflist[count][i].print();
        cout << "Max cost for this tree = " << costlist[count] << endl;
        cout << endl;
        if (listoflist[count].size() < npieces)
            notdone = false;
        count++;
=======
    typename DClass<D>::KeyD root(0);
    this->skeltree->fixCost(root);
//madness::print("findBestPartition: about to depthFirstPartition");
//    this->skeltree->print(root);
    totalCost = this->skeltree->depthFirstPartition(root, &listoflist[count], npieces, 
	totalCost, &costlist[count]);
//madness::print("findBestPartition: after depthFirstPartition");
    int size = listoflist[count].size();
    cout << "Partitioned tree " << count << ":" << endl;
    for (int i = 0; i < size; i++)
	listoflist[count][i].print();
    cout << "Max cost for this tree = " << costlist[count] << endl;
    cout << endl;
    if (listoflist[count].size() < npieces)
	notdone = false;
    count++;
>>>>>>> .r223

<<<<<<< .mine
        while (notdone) {
            //	this->skeltree.fixCost<D>(root);
            this->skeltree->template fixCost(root);
            //	this->skeltree.rollup<D>(root);
            this->skeltree->template rollup(root);
            listoflist.push_back(emptylist);
            costlist.push_back(0);
            this->skeltree->template depthFirstPartition(root, &listoflist[count], npieces, totalCost, &costlist[count]);
            int size = listoflist[count].size();
            cout << "Partitioned tree " << count << ":" << endl;
            for (int i = 0; i < size; i++)
                listoflist[count][i].print();
            cout << "Max cost for this tree = " << costlist[count] << endl;
            cout << endl;
=======
    while (notdone) {
	this->skeltree->fixCost(root); 
	this->skeltree->rollup(root);
	listoflist.push_back(emptylist);
	costlist.push_back(0);
	this->skeltree->depthFirstPartition(root, &listoflist[count], npieces, totalCost, &costlist[count]);
	int size = listoflist[count].size();
	cout << "Partitioned tree " << count << ":" << endl;
	for (int i = 0; i < size; i++)
	    listoflist[count][i].print();
	cout << "Max cost for this tree = " << costlist[count] << endl;
	cout << endl;
	
    	typename DClass<D>::treeT::iterator it = this->skeltree->find(root);
    	if (it == this->skeltree->end()) return klist;
    	typename DClass<D>::NodeD node = it->second;
	if (!(node.has_children()) || (listoflist[count].size() < npieces)) {
	    notdone = false;
	}
	if (listoflist[count].size() < npieces) {
	    listoflist.erase(listoflist.begin()+count);
	    break;
	}
	count++;
    }
    unsigned int shortestList = 0, SL_index, LB_index;
    Cost loadBalCost = 0;
    vector<unsigned int> len;
    for (int i = 0; i < count; i++) {
	len.push_back(listoflist[i].size());
	if ((len[i] < shortestList) || (shortestList == 0)) {
	    shortestList = len[i];
	    SL_index = i;
	}
	else if ((len[i] == shortestList) && (costlist[i] < costlist[SL_index])) {
	// all things being equal, prefer better balance
	    shortestList = len[i];
	    SL_index = i;
	}
	if ((costlist[i] < loadBalCost) || (loadBalCost == 0)) {
	    loadBalCost = costlist[i];
	    LB_index = i;
	}
	else if ((costlist[i] == loadBalCost) && (len[i] < listoflist[LB_index].size())) {
	// all things being equal, prefer fewer cuts
	    loadBalCost = costlist[i];
	    LB_index = i;
	}
    }
>>>>>>> .r223

            //    	typename DClass<D>::treeT::iterator it = this->skeltree.find(root);
            typename DClass<D>::treeT::iterator it = this->skeltree->find(root);
            //    	if (it == this->skeltree.end()) return klist;
            if (it == this->skeltree->end()) return klist;
            typename DClass<D>::NodeD node = it->second;
            if (!(node.has_children()) || (listoflist[count].size() < npieces)) {
                notdone = false;
            }
            if (listoflist[count].size() < npieces) {
                listoflist.erase(listoflist.begin()+count);
                break;
            }
            count++;
        }
        unsigned int shortestList = 0, SL_index, LB_index;
        Cost loadBalCost = 0;
        vector<unsigned int> len;
        for (int i = 0; i < count; i++) {
            len.push_back(listoflist[i].size());
            if ((len[i] < shortestList) || (shortestList == 0)) {
                shortestList = len[i];
                SL_index = i;
            } else if ((len[i] == shortestList) && (costlist[i] < costlist[SL_index])) {
                // all things being equal, prefer better balance
                shortestList = len[i];
                SL_index = i;
            }
            if ((costlist[i] < loadBalCost) || (loadBalCost == 0)) {
                loadBalCost = costlist[i];
                LB_index = i;
            } else if ((costlist[i] == loadBalCost) && (len[i] < listoflist[LB_index].size())) {
                // all things being equal, prefer fewer cuts
                loadBalCost = costlist[i];
                LB_index = i;
            }
        }

        cout << "The load balance with the fewest broken links has cost " << costlist[SL_index] <<
        ", and " << shortestList-1 << " broken links" << endl;
        for (unsigned int i = 0; i < shortestList; i++) {
            listoflist[SL_index][i].print();
        }
        cout << endl;
        cout << "The load balance with the best balance has cost " << loadBalCost << ", and " <<
        listoflist[LB_index].size()-1 << " broken links" << endl;
        for (unsigned int i = 0; i < listoflist[LB_index].size(); i++) {
            listoflist[LB_index][i].print();
        }
        cout << endl;

        CompCost ccleast = 0;
        int cc_index;
        for (int i = 0; i < count; i++) {
            CompCost cctmp = computeCompCost(costlist[i], len[i]-1);
            if ((i==0) || (cctmp < ccleast)) {
                ccleast = cctmp;
                cc_index = i;
            }
        }
        cout << "The load balance with the best overall computational cost has cost " <<
        costlist[cc_index] << " and " << len[cc_index]-1 << " broken links" << endl;
        for (unsigned int i = 0; i < len[cc_index]; i++) {
            listoflist[cc_index][i].print();
        }
        for (unsigned int i = 0; i < len[cc_index]; i++) {
            klist.push_back(listoflist[cc_index][i]);
        }

        print("findBestPartition: about to do fence");
        this->f.impl->world.gop.fence();
        print("about to do broadcast");
        unsigned int ksize = klist.size();
        this->f.impl->world.gop.template broadcast<unsigned int>(ksize);
        for (unsigned int i=0; i < ksize; i++) {
            this->f.impl->world.gop.template broadcast<typename DClass<D>::TreeCoords>(klist[i]);
        }
        print("done with broadcast");

        return klist;
    }

<<<<<<< .mine
=======
template <int D, typename Pmap>
Cost LBTree<D,Pmap>::fixCost(typename DClass<D>::KeyDConst& key) {
//    madness::print("fixCost: key =", key, " is about to be looked for");
    typename DClass<D>::treeT::iterator it = this->find(key);
//    madness::print("fixCost: key =", key, " was found (looked for),", (it == this->end()));
    if (it == this->end()) return 0;
//    madness::print("fixCost: tree it was found (exists)");
>>>>>>> .r223

<<<<<<< .mine
    template <int D>
    Cost LBTree<D>::fixCost(typename DClass<D>::KeyDConst& key) {
        madness::print("fixCost: key =", key, " is about to be looked for");
        typename DClass<D>::treeT::iterator it = this->find(key);
        madness::print("fixCost: key =", key, " was found (looked for),", (it == this->end()));
        if (it == this->end()) return 0;
        madness::print("fixCost: tree it was found (exists)");

        typename DClass<D>::NodeD node = it->second;
        madness::print("fixCost: got node");
        NodeData d = node.get_data();
        madness::print("fixCost: got data from node");
        d.subcost = d.cost;
        madness::print("fixCost: assigned node cost to subcost");
        if (node.has_children()) {
            madness::print("fixCost: node has children");
            for (KeyChildIterator<D> kit(key); kit; ++kit) {
                d.subcost += this->template fixCost(kit.key());
            }
        }
        node.set_data(d);
        madness::print("fixCost: about to insert key =", key, ",", node.get_data());
        this->insert(key,node);
        madness::print("fixCost: inserted node");
        return d.subcost;
=======
    typename DClass<D>::NodeD node = it->second;
//    madness::print("fixCost: got node");
    NodeData d = node.get_data();
//    madness::print("fixCost: got data from node");
    d.subcost = d.cost;
//    madness::print("fixCost: assigned node cost to subcost");
    if (node.has_children())
    {
//	madness::print("fixCost: node has children");
	for (KeyChildIterator<D> kit(key); kit; ++kit) {
	    d.subcost += this->fixCost(kit.key());
	}
>>>>>>> .r223
    }
<<<<<<< .mine
=======
    node.set_data(d);
//madness::print("fixCost: about to insert key =", key, ",", node.get_data());
    this->insert(key,node);
//madness::print("fixCost: inserted node");
    return d.subcost;
}
>>>>>>> .r223


    template <int D>
    Cost LBTree<D>::depthFirstPartition(typename DClass<D>::KeyDConst& key,
            vector<typename DClass<D>::TreeCoords>* klist, unsigned int npieces,
            Cost totalcost, Cost *maxcost) {
//madness::print("depthFirstPartition: at very beginning");
<<<<<<< .mine
        if (totalcost == 0) {
            totalcost = this->template computeCost(key);
        }
        madness::print("depthFirstPartition: totalcost =", totalcost);
=======
    if (totalcost == 0) {
	totalcost = this->computeCost(key);
    }
//madness::print("depthFirstPartition: totalcost =", totalcost);
>>>>>>> .r223

        Cost costLeft = totalcost;
        int partsLeft = npieces;
        *maxcost = 0;
        Cost partitionSize = 0;
    double facter = 1.1;

<<<<<<< .mine
        for (int i = npieces-1; i >= 0; i--) {
            cout << endl << "Beginning partition number " << i << endl;
            vector<typename DClass<D>::KeyD> tmplist;
            Cost tpart = computePartitionSize(costLeft, partsLeft);
            if (tpart > partitionSize) {
                partitionSize = tpart;
            }
            madness::print("depthFirstPartition: partitionSize =", partitionSize);
            Cost usedUp = 0;
            bool atleaf = false;
            usedUp = this->template makePartition(key, &tmplist, partitionSize, (i==0), usedUp, &atleaf);
            if (*maxcost < usedUp) *maxcost = usedUp;
            costLeft -= usedUp;
            partsLeft--;
            for (unsigned int j = 0; j < tmplist.size(); j++) {
                klist->push_back(typename DClass<D>::TreeCoords(typename DClass<D>::KeyD(tmplist[j]), i));
            }
        }
        return totalcost;
=======
    for (int i = npieces-1; i >= 0; i--) {
	cout << endl << "Beginning partition number " << i << endl;
	vector<typename DClass<D>::KeyD> tmplist;
	Cost tpart = computePartitionSize(costLeft, partsLeft);
	if ((tpart > partitionSize) || (tpart*facter < partitionSize)) {
	    partitionSize = tpart;
	}
//madness::print("depthFirstPartition: partitionSize =", partitionSize);
	Cost usedUp = 0;
	bool atleaf = false;
	usedUp = this->makePartition(key, &tmplist, partitionSize, (i==0), usedUp, &atleaf);
	if (*maxcost < usedUp) *maxcost = usedUp;
	costLeft -= usedUp;
	partsLeft--;
	for (unsigned int j = 0; j < tmplist.size(); j++) {
	    klist->push_back(typename DClass<D>::TreeCoords(typename DClass<D>::KeyD(tmplist[j]), i)); 
	}
>>>>>>> .r223
    }

    template <int D>
    void LBTree<D>::rollup(typename DClass<D>::KeyDConst& key) {
//    madness::print("rollup: at beginning");
        typename DClass<D>::treeT::iterator it = this->find(key);
        if (it == this->end()) return;

//    madness::print("rollup: about to get node associated with key",key);
        typename DClass<D>::NodeD node = it->second;
        if (!node.has_children()) {
//	madness::print("rollup: this node has no children; returning");
            return; // no rolling to be done here.
        }
//    madness::print("rollup: this node has children");
        bool hasleafchild = false;
        for (KeyChildIterator<D> kit(key); kit; ++kit) {
            typename DClass<D>::treeT::iterator itc = this->find(kit.key());
            if (itc != this->end()) {
//	    madness::print("rollup: found child", kit.key());
                typename DClass<D>::NodeD c = itc->second;
                if (!c.has_children()) {
//		madness::print("rollup: child is leaf");
                    hasleafchild = true;
                    break;
                } else {
//		madness::print("rollup: child", kit.key(), "has children");
                }
            }
        }
        if (hasleafchild) {
//	madness::print("rollup: about to meld with key",key);
<<<<<<< .mine
            this->template meld(key);
        }
        for (KeyChildIterator<D> kit(key); kit; ++kit) {
            typename DClass<D>::treeT::iterator itc = this->find(kit.key());
            if (itc != this->end()) {
=======
	this->meld(key);
    }
    for (KeyChildIterator<D> kit(key); kit; ++kit) {
	typename DClass<D>::treeT::iterator itc = this->find(kit.key());
	if (itc != this->end()) {
>>>>>>> .r223
//	    madness::print("rollup: found child", kit.key());
                typename DClass<D>::NodeD c = itc->second;
                if (c.has_children()) {
//		madness::print("rollup: child", kit.key(), "has children");
<<<<<<< .mine
                    this->template rollup(kit.key());
                }
            }
        }
        it = this->find(key);
        node = it->second;
        NodeData d = node.get_data();
        if (d.istaken) {
            d.istaken = false;
            node.set_data(d);
            this->insert(key,node);
        }
=======
		this->rollup(kit.key());
	    }
	}
>>>>>>> .r223
    }

    template <int D>
    void LBTree<D>::meld(typename DClass<D>::KeyDConst& key) {
//    madness::print("meld: at beginning, finding key", key);
        Cost cheapest = 0;
        typename DClass<D>::treeT::iterator it = this->find(key);
        if (it == this->end()) return;

        vector<unsigned int> mylist;

        typename DClass<D>::NodeD node = it->second;
        unsigned int i = 0;
//    madness::print("meld: about to iterate over children of key", key);
        for (KeyChildIterator<D> kit(key); kit; ++kit) {
//    	madness::print("    meld: iterating over child", i);
            if (node.has_child(i)) {
                typename DClass<D>::treeT::iterator itc = this->find(kit.key());
                if (itc == this->end()) return;
                typename DClass<D>::NodeD c = itc->second;
                if (!c.has_children()) {
//		madness::print("    meld: child",i,"has no children");
                    Cost cost = c.get_data().cost;
                    if ((cost < cheapest) || (cheapest == 0)) {
                        cheapest = cost;
                        mylist.clear();
                        mylist.push_back(i);
                    } else if (cost == cheapest) {
                        mylist.push_back(i);
                    }
                }
            }
            i++;
        }

        if (cheapest == 0) {
//	madness::print("meld: this node has no leaf children");
            NodeData d = node.get_data();
            d.istaken = false;
            node.set_data(d);
            this->insert(key,node);
            return;
        }

        NodeData d = node.get_data();

        i = 0;
        int j = 0, mlsize = mylist.size();
        for (KeyChildIterator<D> kit(key); kit; ++kit) {
            if (mylist[j] == i) {
//	    madness::print("meld: found a match, mylist[",j,"] =",i);
                this->erase(kit.key());
                node.set_child(mylist[j], false);
                d.cost += cheapest;
                j++;
            }
            i++;
            if (j == mlsize) break;
        }
        d.istaken = false;
        node.set_data(d);
        this->insert(key,node);
//    madness::print("meld: inserted node back into tree; goodbye!");
    }


    template <int D>
    Cost LBTree<D>::computeCost(typename DClass<D>::KeyDConst& key) {
        Cost cost = 0;
        typename DClass<D>::treeT::iterator it = this->find(key);
        if (it == this->end()) return cost;

<<<<<<< .mine
        typename DClass<D>::NodeD node = it->second;
        for (KeyChildIterator<D> kit(key); kit; ++kit) {
            cost += this->template computeCost(kit.key());
        }
        NodeData d = node.get_data();
        cost += d.cost;

        d.subcost = cost;
        node.set_data(d);
        this->insert(key,node);
        return cost;
=======
    typename DClass<D>::NodeD node = it->second;
    for (KeyChildIterator<D> kit(key); kit; ++kit) {
	cost += this->computeCost(kit.key());
>>>>>>> .r223
    }


    template <int D>
    Cost LBTree<D>::makePartition(typename DClass<D>::KeyDConst& key,
                                       vector<typename DClass<D>::KeyD>* klist, Cost partitionSize, bool lastPartition,
                                       Cost usedUp, bool *atleaf) {
//    madness::print("at beginning of makePartition: atleaf =", *atleaf);
        double fudgeFactor = 0.1;
        Cost maxAddl = (Cost) (fudgeFactor*partitionSize);

        typename DClass<D>::treeT::iterator it = this->find(key);
        if (it == this->end()) {
            return usedUp;
        }

        typename DClass<D>::NodeD node = it->second;
        NodeData d = node.get_data();

        it = this->end();

<<<<<<< .mine
        madness::print("makePartition: data for key", key, ":", d);
        madness::print("makePartition: partitionSize =", partitionSize, ", lastPartition =", lastPartition, ", usedUp =", usedUp);
=======
//    madness::print("makePartition: data for key", key, ":", d);
//    madness::print("makePartition: partitionSize =", partitionSize, ", lastPartition =", lastPartition, ", usedUp =", usedUp);
>>>>>>> .r223

<<<<<<< .mine
        if (d.istaken) {
            madness::print("makePartition: this key is taken");
            return usedUp;
        }
=======
    if (d.istaken) {
//	madness::print("makePartition: this key is taken"); 
	return usedUp;
    }
>>>>>>> .r223

<<<<<<< .mine
        madness::print("makePartition: back to key", key);
=======
//    madness::print("makePartition: back to key", key);
>>>>>>> .r223

<<<<<<< .mine
        // if either we're at the last partition, the partition is currently empty
        // and this is a single item, or there is still room in the partition and
        // adding this to it won't go above the fudge factor,
        // then add this piece to the partition.
        if ((lastPartition) || ((usedUp == 0) && (!node.has_children())) ||
                ((usedUp < partitionSize) && (d.subcost+usedUp <= partitionSize+maxAddl))) {
            // add to partition
            madness::print("makePartition: adding to partition", key);
            klist->push_back(typename DClass<D>::KeyD(key));
            d.istaken = true;
            usedUp += d.subcost;
            // REMOVE COST FROM FOREPARENTS (implement this)
            this->template removeCost(key.parent(), d.subcost);
            node.set_data(d);
            this->insert(key,node);
        } else if (usedUp < partitionSize) {
            // try this node's children (if any)
            if (node.has_children()) {
                int i = 0;
                for (KeyChildIterator<D> kit(key); kit; ++kit) {
                    if (node.has_child(i)) {
                        madness::print("makePartition:", key, "recursively calling", kit.key());
                        usedUp = this->template makePartition(kit.key(), klist, partitionSize, lastPartition,
                                                              usedUp, atleaf);
                        if ((*atleaf) || (usedUp >= partitionSize)) {
                            break;
                        }
                    }
                    i++;
                }
            } else {
                madness::print("makePartition: about to set atleaf = true");
                *atleaf = true;
            }
        }
        return usedUp;
=======
    // if either we're at the last partition, the partition is currently empty
    // and this is a single item, or there is still room in the partition and
    // adding this to it won't go above the fudge factor,
    // then add this piece to the partition.
    if ((lastPartition) || ((usedUp == 0) && (!node.has_children())) || 
	((usedUp < partitionSize) && (d.subcost+usedUp <= partitionSize+maxAddl))) {
	// add to partition
//	madness::print("makePartition: adding to partition", key);
	klist->push_back(typename DClass<D>::KeyD(key));
	d.istaken = true;
	usedUp += d.subcost;
	// REMOVE COST FROM FOREPARENTS (implement this)
	this->removeCost(key.parent(), d.subcost);
	node.set_data(d);
	this->insert(key,node);
>>>>>>> .r223
    }
<<<<<<< .mine
=======
    else if (usedUp < partitionSize) {
	// try this node's children (if any) 
	if (node.has_children()) {
	    int i = 0;
	    for (KeyChildIterator<D> kit(key); kit; ++kit) {
		if (node.has_child(i)) {
//		    madness::print("makePartition:", key, "recursively calling", kit.key());
		    usedUp = this->makePartition(kit.key(), klist, partitionSize, lastPartition,
			usedUp, atleaf);
		    if ((*atleaf) || (usedUp >= partitionSize)) {
			break;
		    }
		}
		i++;
	    }
	}
	else {
//	    madness::print("makePartition: about to set atleaf = true");
	    *atleaf = true;
	}
    }
    return usedUp;
}
>>>>>>> .r223

<<<<<<< .mine
    template <int D>
    void LBTree<D>::removeCost(typename DClass<D>::KeyDConst& key, Cost c) {
        madness::print("removeCost: key", key, "owner =", owner(key));
        this->get_mypmap().print();
        if (((int) key.level()) < 0) return;
        typename DClass<D>::treeT::iterator it = this->find(key);
        madness::print("removeCost: found key");
        if (it == this->end()) return;
        typename DClass<D>::NodeD node = it->second;
        NodeData d = node.get_data();
        madness::print("removeCost: got data");
        d.subcost -= c;
        if (key.level() > 0) {
            this->template removeCost(key.parent(), c);
        }
        madness::print("removeCost: before setting, data =", d);
        node.set_data(d);
        madness::print("removeCost: after setting, data =", node.get_data());
        this->insert(key,node);
        madness::print("removeCost: after inserting, data = ", node.get_data());
=======
template <int D, typename Pmap>
void LBTree<D,Pmap>::removeCost(typename DClass<D>::KeyDConst& key, Cost c) {
//madness::print("removeCost: key", key, "owner =", owner(key));
//this->get_procmap().print();
    if (((int) key.level()) < 0) return;
    typename DClass<D>::treeT::iterator it = this->find(key);
//madness::print("removeCost: found key");
    if (it == this->end()) return;
    typename DClass<D>::NodeD node = it->second;
    NodeData d = node.get_data();
//madness::print("removeCost: got data");
    d.subcost -= c;
    if (key.level() > 0) {
    	this->removeCost(key.parent(), c);
>>>>>>> .r223
    }
<<<<<<< .mine
=======
//madness::print("removeCost: before setting, data =", d);
    node.set_data(d);
//madness::print("removeCost: after setting, data =", node.get_data());
    this->insert(key,node);
//madness::print("removeCost: after inserting, data = ", node.get_data());
}
>>>>>>> .r223


    Cost computePartitionSize(Cost cost, unsigned int parts) {
        return (Cost) ceil(((double) cost)/((double) parts));
    }


    CompCost computeCompCost(Cost c, int n) {
        CompCost compcost;
        CompCost cfactor = 0.1, nfactor = 1.0;
        compcost = cfactor*c + nfactor*n;
        return compcost;
    }


    template <typename T, int D>
    void migrate_data(SharedPtr<FunctionImpl<T,D> > tfrom, SharedPtr<FunctionImpl<T,D> > tto,
                      typename DClass<D>::KeyD key) {
        typename FunctionImpl<T,D>::iterator it = tfrom->find(key);
        if (it == tfrom->end()) return;

        FunctionNode<T,D> node = it->second;

        if (node.has_children()) {
            for (KeyChildIterator<D> kit(key); kit; ++kit) {
                migrate_data<T,D>(tfrom, tto, kit.key());
            }
        }
        tto->insert(key, node);
    }


<<<<<<< .mine
    template <typename T, int D>
    void migrate(SharedPtr<FunctionImpl<T,D> > tfrom, SharedPtr<FunctionImpl<T,D> > tto) {
        typename DClass<D>::KeyD root(0);
        print("migrate: at beginning");
        migrate_data<T,D>(tfrom, tto, root);
        print("migrate: at end");
    }
=======
template <typename T, int D, typename Pmap>
void migrate(SharedPtr<FunctionImpl<T,D,Pmap> > tfrom, SharedPtr<FunctionImpl<T,D,Pmap> > tto) {
    typename DClass<D>::KeyD root(0);
//print("migrate: at beginning");
    migrate_data<T,D,Pmap>(tfrom, tto, root);
//print("migrate: at end");
}
>>>>>>> .r223

<<<<<<< .mine
    // Explicit instantiations for D=1:6
    template void migrate<double,3,MyPmap<3> >(SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tfrom,
            SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tto);
=======
// Explicit instantiations for D=1:6
>>>>>>> .r223

<<<<<<< .mine
    template void migrate_data<double,3>(SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tfrom,
                                         SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tto, DClass<3>::KeyD key);
=======
>>>>>>> .r223

<<<<<<< .mine

// Who knows why these aren't cooperating, so commented out for now
    /*
    template void migrate_data<double,1>(SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tfrom, 
    	SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tto, DClass<1>::KeyD key);
    template void migrate_data<double,2>(SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tto, DClass<2>::KeyD key);
    template void migrate_data<double,3>(SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tto, DClass<3>::KeyD key);
    template void migrate_data<double,4>(SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tto, DClass<4>::KeyD key);
    template void migrate_data<double,5>(SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tto, DClass<5>::KeyD key);
    template void migrate_data<double,6>(SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tto, DClass<6>::KeyD key);
     
    template void migrate_data<std::complex<double>,1>(SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tto, DClass<1>::KeyD key);
    template void migrate_data<std::complex<double>,2>(SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tto, DClass<2>::KeyD key);
    template void migrate_data<std::complex<double>,3>(SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tto, DClass<3>::KeyD key);
    template void migrate_data<std::complex<double>,4>(SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tto, DClass<4>::KeyD key);
    template void migrate_data<std::complex<double>,5>(SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tto, DClass<5>::KeyD key);
    template void migrate_data<std::complex<double>,6>(SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tto, DClass<6>::KeyD key);
     
    template void migrate<double,1,MyPmap<1> >(SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tfrom, 
    	SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tto);
    template void migrate<double,2,MyPmap<2> >(SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tto);
    template void migrate<double,3,MyPmap<3> >(SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tto);
    template void migrate<double,4,MyPmap<4> >(SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tto);
    template void migrate<double,5,MyPmap<5> >(SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tto);
    template void migrate<double,6,MyPmap<6> >(SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tto);
     
    template void migrate<std::complex<double>,1,MyPmap<1> >(SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tto);
    template void migrate<std::complex<double>,2,MyPmap<2> >(SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tto);
    template void migrate<std::complex<double>,3,MyPmap<3> >(SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tto);
    template void migrate<std::complex<double>,4,MyPmap<4> >(SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tto);
    template void migrate<std::complex<double>,5,MyPmap<5> >(SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tto);
    template void migrate<std::complex<double>,6,MyPmap<6> >(SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tto);
    */
=======
template void migrate_data<double,1>(SharedPtr<FunctionImpl<double,1,MyProcmap<1> > > tfrom, 
	SharedPtr<FunctionImpl<double,1,MyProcmap<1> > > tto, DClass<1>::KeyD key);
template void migrate_data<double,2>(SharedPtr<FunctionImpl<double,2,MyProcmap<2> > > tfrom, 
	SharedPtr<FunctionImpl<double,2,MyProcmap<2> > > tto, DClass<2>::KeyD key);
template void migrate_data<double,3>(SharedPtr<FunctionImpl<double,3,MyProcmap<3> > > tfrom, 
	SharedPtr<FunctionImpl<double,3,MyProcmap<3> > > tto, DClass<3>::KeyD key);
template void migrate_data<double,4>(SharedPtr<FunctionImpl<double,4,MyProcmap<4> > > tfrom, 
	SharedPtr<FunctionImpl<double,4,MyProcmap<4> > > tto, DClass<4>::KeyD key);
template void migrate_data<double,5>(SharedPtr<FunctionImpl<double,5,MyProcmap<5> > > tfrom, 
	SharedPtr<FunctionImpl<double,5,MyProcmap<5> > > tto, DClass<5>::KeyD key);
template void migrate_data<double,6>(SharedPtr<FunctionImpl<double,6,MyProcmap<6> > > tfrom, 
	SharedPtr<FunctionImpl<double,6,MyProcmap<6> > > tto, DClass<6>::KeyD key);
>>>>>>> .r223

    template class LoadBalImpl<double,1,MyPmap<1> >;
    template class LoadBalImpl<double,2,MyPmap<2> >;
    template class LoadBalImpl<double,3,MyPmap<3> >;
    template class LoadBalImpl<double,4,MyPmap<4> >;
    template class LoadBalImpl<double,5,MyPmap<5> >;
    template class LoadBalImpl<double,6,MyPmap<6> >;

    template class LoadBalImpl<std::complex<double>,1,MyPmap<1> >;
    template class LoadBalImpl<std::complex<double>,2,MyPmap<2> >;
    template class LoadBalImpl<std::complex<double>,3,MyPmap<3> >;
    template class LoadBalImpl<std::complex<double>,4,MyPmap<4> >;
    template class LoadBalImpl<std::complex<double>,5,MyPmap<5> >;
    template class LoadBalImpl<std::complex<double>,6,MyPmap<6> >;

<<<<<<< .mine
    template class LBTree<1,MyPmap<1> >;
    template class LBTree<2,MyPmap<2> >;
    template class LBTree<3,MyPmap<3> >;
    template class LBTree<4,MyPmap<4> >;
    template class LBTree<5,MyPmap<5> >;
    template class LBTree<6,MyPmap<6> >;
=======
// Who knows why this isn't cooperating, so commented out for now
/*
template void migrate<std::complex<double>,1,MyProcmap<1> >(SharedPtr<FunctionImpl<std::complex<double>,1,MyProcmap<1> > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,1,MyProcmap<1> > > tto);
*/
template void migrate<std::complex<double>,2,MyProcmap<2> >(SharedPtr<FunctionImpl<std::complex<double>,2,MyProcmap<2> > > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,2,MyProcmap<2> > > tto);
template void migrate<std::complex<double>,3,MyProcmap<3> >(SharedPtr<FunctionImpl<std::complex<double>,3,MyProcmap<3> > > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,3,MyProcmap<3> > > tto);
template void migrate<std::complex<double>,4,MyProcmap<4> >(SharedPtr<FunctionImpl<std::complex<double>,4,MyProcmap<4> > > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,4,MyProcmap<4> > > tto);
template void migrate<std::complex<double>,5,MyProcmap<5> >(SharedPtr<FunctionImpl<std::complex<double>,5,MyProcmap<5> > > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,5,MyProcmap<5> > > tto);
template void migrate<std::complex<double>,6,MyProcmap<6> >(SharedPtr<FunctionImpl<std::complex<double>,6,MyProcmap<6> > > tfrom, 
	SharedPtr<FunctionImpl<std::complex<double>,6,MyProcmap<6> > > tto);


template class LoadBalImpl<double,1,MyProcmap<1> >;
template class LoadBalImpl<double,2,MyProcmap<2> >;
template class LoadBalImpl<double,3,MyProcmap<3> >;
template class LoadBalImpl<double,4,MyProcmap<4> >;
template class LoadBalImpl<double,5,MyProcmap<5> >;
template class LoadBalImpl<double,6,MyProcmap<6> >;

template class LoadBalImpl<std::complex<double>,1,MyProcmap<1> >;
template class LoadBalImpl<std::complex<double>,2,MyProcmap<2> >;
template class LoadBalImpl<std::complex<double>,3,MyProcmap<3> >;
template class LoadBalImpl<std::complex<double>,4,MyProcmap<4> >;
template class LoadBalImpl<std::complex<double>,5,MyProcmap<5> >;
template class LoadBalImpl<std::complex<double>,6,MyProcmap<6> >;

template class LBTree<1,MyProcmap<1> >;
template class LBTree<2,MyProcmap<2> >;
template class LBTree<3,MyProcmap<3> >;
template class LBTree<4,MyProcmap<4> >;
template class LBTree<5,MyProcmap<5> >;
template class LBTree<6,MyProcmap<6> >;
>>>>>>> .r223
}
#define WORLD_INSTANTIATE_STATIC_TEMPLATES
#ifndef LOADBAL_H
#define LOADBAL_H

#include <world/world.h>
#include <mra/key.h>
#include <mra/mra.h>
using namespace std;

namespace madness {

    typedef int Cost;
    typedef double CompCost;

    inline int nearest_power(int me, int d) {
        int k = 0;
        while (me != 0) {
            if (me%d == 0) {
                k++;
                me/=d;
            } else {
                break;
            }
        }
        return k;
    };

    template <typename Data, int D> class LBNode;
    template <int D> struct TreeCoords;
    template <int D> struct Tree;
    template <int D> class MyPmap;
    template <int D> class LBTree;
    class NodeData;

    template <int D>
    struct DClass {
        typedef Key<D> KeyD;
        typedef const Key<D> KeyDConst;
        typedef TreeCoords<D> TreeCoords;
        typedef Tree<D> Tree;
        typedef LBNode<NodeData,D> NodeD;
        typedef const LBNode<NodeData,D> NodeDConst;
        typedef MyPmap<D> MyPmap;
        typedef LBTree<D> treeT;
    };

    template <typename T, int D>
    void migrate(SharedPtr<FunctionImpl<T,D> > tfrom, SharedPtr<FunctionImpl<T,D> > tto);

<<<<<<< .mine
    template <typename T, int D>
    void migrate_data(SharedPtr<FunctionImpl<T,D> > tfrom, SharedPtr<FunctionImpl<T,D> > tto,
                      typename DClass<D>::KeyD key);
=======
template <int D>
struct DClass {
    typedef Key<D> KeyD;
    typedef const Key<D> KeyDConst;
    typedef TreeCoords<D> TreeCoords;
    typedef Tree<D> Tree;
    typedef LBNode<NodeData,D> NodeD;
    typedef const LBNode<NodeData,D> NodeDConst;
    typedef MyProcmap<D> MyProcMap;
    typedef LBTree<D,MyProcMap> treeT;
};
>>>>>>> .r223

    template <typename Data, int D>
    class LBNode {
    private:
        Data data;
        std::vector<bool> c;

        void allchildren(bool status=false) {
            c.clear();
            c.assign(dim, status);
        };

    public:
        static int dim;

        LBNode() {
            data = Data();
            allchildren();
        };

        LBNode(Data d, bool children=false) : data(d) {
            allchildren(children);
        };

        bool has_children() const {
            for (int i = 0; i < dim; i++)
                if (c[i]) return true;
            return false;
        };

        bool has_child(unsigned int i) const {
            return c[i];
        };

        bool has_child(int i) const {
            return c[i];
        };

        void set_child(int i, bool setto = true) {
            c[i] = setto;
        };

        void set_data(Data d) {
            data = d;
        };

        Data get_data() const {
            return data;
        };

        vector<bool> get_c() const {
            return c;
        };

        template <typename Archive>
        void serialize(const Archive& ar) {
            ar & data & c;
        }
    };


    template <typename Data, int D>
    std::ostream& operator<<(std::ostream& s, const LBNode<Data, D>& node) {
        s << "data = " << node.get_data() << ", c = " << node.get_c();
        return s;
    };

    template <int D>
    std::ostream& operator<<(std::ostream& s, typename DClass<D>::NodeDConst& node) {
        s << "data = " << node.get_data() << ", c = " << node.get_c();
        return s;
    };


    template <typename Data, int D>
    int LBNode<Data,D>::dim = power<D>();


    class NodeData {
        friend std::ostream& operator<<(std::ostream& s, const NodeData& nd);
    public:
        int cost;
        int subcost;
        bool istaken;
        NodeData(int c = 1, int s = 1, bool i = false) : cost(c), subcost(s), istaken(i) {};
        template <typename Archive>
        void serialize(const Archive& ar) {
            ar & cost & subcost & istaken;
        };
        void print() {
            cout << "cost = " << cost << ", subcost = " << subcost << ", istaken = " << istaken << endl;
        };
    };


    inline std::ostream& operator<<(std::ostream& s, const NodeData& nd) {
        s << "cost " << nd.cost << ", subcost " << nd.subcost << ", istaken " << nd.istaken;
        return s;
    };



    template <int D>
    struct TreeCoords {
        Key<D> key;
        ProcessID owner;

        TreeCoords(const Key<D> k, ProcessID o) : key(Key<D>(k)), owner(o) {};
        TreeCoords(const TreeCoords& t) : key(Key<D>(t.key)), owner(t.owner) {};
        TreeCoords() : key(Key<D>()), owner(-1) {};
        void print() const {
            madness::print(key, "   owner =", owner);
        };

        bool operator< (const TreeCoords t) const {
            return (this->key < t.key);
        };
    };



    template <int D>
    struct Tree {
        TreeCoords<D> data;
        vector<SharedPtr<Tree> > children;
        Tree* parent;

        Tree() {};
        Tree(TreeCoords<D> d) : data(d), parent(0) {};
        Tree(TreeCoords<D> d, Tree* p) : data(d), parent(p) {};

        Tree(const Tree<D>& tree) : data(tree.data), parent(0) {};
        Tree(const Tree<D>& tree, Tree* p) : data(tree.data), parent(p) {};

        Tree<D>& operator=(const Tree<D>& other) {
            if (this != &other) {
                this->data = other.data;
                this->parent = other.parent;
                this->children = other.children;
            }
            return *this;
        };

        void insertChild(TreeCoords<D> d) {
            Tree* c = new Tree(d, this);
            children.insert(children.begin(),SharedPtr<Tree<D> > (c));
        };

        void insertChild(const Tree<D>& tree) {
            Tree* c = new Tree(tree, this);
            children.insert(children.begin(),SharedPtr<Tree<D> > (c));
        };

        void print() {
            data.print();
            int csize = children.size();
            for (int j = 0; j < csize; j++) {
                children[j]->print();
            }
        };

        bool isForeparentOf(Key<D> key) const {
            return (this->data.key.is_parent_of(key));
        };

        void findOwner(const Key<D> key, ProcessID *ow) const {
//madness::print("findOwner: at node", this->data.key);
            if (this->isForeparentOf(key)) {
//madness::print("findOwner: node", this->data.key, "is foreparent of", key, "so owner =", this->data.owner);
                *ow = this->data.owner;
                if (this->data.key.level() < key.level()) {
                    int csize = children.size();
                    for (int j = 0; j < csize; j++) {
//madness::print("findOwner: recursively call on ", this->children[j]->data.key);
                        children[j]->findOwner(key, ow);
                    }
                }
            }
        };

        bool fill(TreeCoords<D> node) {
            bool success = false;
            if (this->isForeparentOf(node.key)) {
                int csize = children.size();
                for (int i = 0; i < csize; i++) {
                    if (children[i]->isForeparentOf(node.key)) {
                        success = children[i]->fill(node);
                    }
                }
                if (!success) {
                    this->insertChild(node);
                    success = true;
                }
            }
            return success;
        }
    };



    template <int D>
    class MyPmap : public WorldDCPmapInterface< Key<D> > {
    private:
        bool static_map;
        const ProcessID staticmap_owner;
        Tree<D>* treeMap;
        typedef Key<D> KeyD;

        void buildTreeMap(vector<TreeCoords<D> > v) {
            sort(v.begin(), v.end());
            int vlen = v.size();

            if (vlen == 0) throw "empty map!!!";

<<<<<<< .mine
            treeMap = new Tree<D>(v[vlen-1]);
            for (int j = vlen-2; j >= 0; j--) {
                treeMap->fill(v[j]);
            }
        };
=======
    ProcessID getOwner(const KeyD& key) const {
	ProcessID owner;
	treeMap->findOwner(key, &owner);
	return owner;
    };
>>>>>>> .r223


    public:
        MyPmap() : staticmap(false), staticmap_owner(0) {};

        MyPmap(World& world) : staticmap(false), staticmap_owner(0) {
            int NP = world.nproc();
            int twotoD = power<D>();
            const int level = nearest_power(NP, twotoD);
            int NPin = (int) pow((double)twotoD,level);
            vector<TreeCoords<D> > v;

<<<<<<< .mine
            for (Translation i=0; i < (Translation)NPin; i++) {
                KeyD key(level,i);
                if ((i%twotoD) == 0) {
                    key = key.parent(nearest_power(NPin-i, twotoD));
                }
                v.push_back(TreeCoords<D>(key,i));
            }
            buildTreeMap(v);
            madness::print("MyPmap constructor");
            treeMap->print();
        };
=======
	treeMap = new Tree<D>(v[vlen-1]);
	for (int j = vlen-2; j >= 0; j--) {
	    treeMap->fill(v[j]);
	}
    };
	
>>>>>>> .r223

        MyPmap(World& world, ProcessID owner) : staticmap(true), owner(owner) {};

        MyPmap(World& world, vector<TreeCoords<D> > v) : staticmap(false), owner(1) { // owner????????????????
            buildTreeMap(v);
            madness::print("");
            treeMap->print();
        };

        MyPmap(const MyPmap<D>& other) : staticmap(other.staticmap), owner(other.owner), treeMap(other.treeMap) {};

        MyPmap<D>& operator=(const MyPmap<D>& other) {
            if (this != &other) {
                staticmap = other.staticmap;
                owner = other.owner;
                treeMap = other.treeMap;
            }
            return *this;
        };

        void print() {
            treeMap->print();
        };

        ProcessID Owner(const KeyD& key) const {
            if (staticmap)
                return staticmap_owner;
            else {
                ProcessID owner;
                treeMap->findOwner(key, &owner);
                return owner;
            }
        };
    };

    template <int D>
    class LBTree : public WorldContainer<typename DClass<D>::KeyD,typename DClass<D>::NodeD> {
        // No new variables necessary
    public:
<<<<<<< .mine
        typedef WorldContainer<typename DClass<D>::KeyD,typename DClass<D>::NodeD> dcT;
        LBTree() {};
        LBTree(World& world, const SharedPtr< WorldDCPmapInterface<DClass<D>::KeyD> >& pmap) : dcT(world,pmap) {
            madness::print("LBTree(world, pmap) constructor");
            this->get_mypmap()->print();
            madness::print("LBTree(world, pmap) constructor (goodbye)");
        };
        template <typename T>
        inline void init_tree(SharedPtr< FunctionImpl<T,D> > f, typename DClass<D>::KeyDConst key) {
            // find Node associated with key
            typename FunctionImpl<T,D>::dcT::iterator it = f->coeffs.find(key);
            if (it == f->coeffs.end()) return;
            // convert Node to LBNode
            NodeData nd;
            if (!(it->second.has_children())) {
                typename DClass<D>::NodeD lbnode(nd,false);
                // insert into "this"
                this->insert(key, lbnode);
            } else {
                typename DClass<D>::NodeD lbnode(nd,true);
                // insert into "this"
                this->insert(key, lbnode);
                // then, call for each child
                for (KeyChildIterator<D> kit(key); kit; ++kit) {
                    this->init_tree<T>(f, kit.key());
                }
            }
        };
=======
	typedef WorldContainer<typename DClass<D>::KeyD,typename DClass<D>::NodeD, Pmap> dcT;

	LBTree() {};
	LBTree(World& world, const Pmap& pmap) : dcT(world,pmap) {
	    this->get_procmap().print();
	};

	template <typename T>
	inline void init_tree(SharedPtr<FunctionImpl<T,D,Pmap> > f, typename DClass<D>::KeyDConst key) {
	    // find Node associated with key
	    typename FunctionImpl<T,D,Pmap>::iterator it = f->find(key);
	    if (it == f->end()) return;
	    // convert Node to LBNode
	    NodeData nd;
	    if (!(it->second.has_children())) {
		typename DClass<D>::NodeD lbnode(nd,false);
	        // insert into "this"
		this->insert(key, lbnode);
	    }
	    else {
		typename DClass<D>::NodeD lbnode(nd,true);
	        // insert into "this"
		this->insert(key, lbnode);
		// then, call for each child
		for (KeyChildIterator<D> kit(key); kit; ++kit) {
		    this->init_tree<T>(f, kit.key());
		}
	    }
	};
>>>>>>> .r223

        // Methods:
        void print(typename DClass<D>::KeyDConst& key) {
            typename DClass<D>::treeT::iterator it = this->find(key);
            if (it == this->end()) return;
            for (Level i = 0; i < key.level(); i++) cout << "  ";
            madness::print(key, it->second);
            for (KeyChildIterator<D> kit(key); kit; ++kit) {
                print(kit.key());
            }
        };

        Cost fixCost(typename DClass<D>::KeyDConst& key);

        Cost depthFirstPartition(typename DClass<D>::KeyDConst& key,
                                 vector<typename DClass<D>::TreeCoords>* klist, unsigned int npieces,
                                 Cost totalcost = 0, Cost *maxcost = 0);

        void rollup(typename DClass<D>::KeyDConst& key);

        void meld(typename DClass<D>::KeyDConst& key);

        Cost makePartition(typename DClass<D>::KeyDConst& key,
                           vector<typename DClass<D>::KeyD>* klist, Cost partitionSize,
                           bool lastPartition, Cost usedUp, bool *atleaf);

        void removeCost(typename DClass<D>::KeyDConst& key, Cost c);

        Cost computeCost(typename DClass<D>::KeyDConst& key);

        // inherited methods
        typename WorldContainer<typename DClass<D>::KeyD,typename DClass<D>::NodeD>::iterator 
        end() {
            return WorldContainer<typename DClass<D>::KeyD, typename DClass<D>::NodeD>::end();
        };

        typename WorldContainer<typename DClass<D>::KeyD,typename DClass<D>::NodeD>::iterator
        find(typename DClass<D>::KeyDConst& key) {
            return WorldContainer<typename DClass<D>::KeyD, typename DClass<D>::NodeD>::find(key);
        };

//         const SharedPtr<WorldDCPmapInterface< DClass<D>::KeyD >& get_pmap() {
//             return WorldContainer<typename DClass<D>::KeyD, typename DClass<D>::NodeD>::get_pmap();
//         };

        MyPmap<D>& get_mypmap() {
            return *static_cast< MyPmap<D>* >(get_pmap().get());
        };

    };

    template <typename T, int D, typename Pmap=MyPmap<D> >
    class LoadBalImpl {
    private:
        Function<T,D,Pmap> f;
        SharedPtr<typename DClass<D>::treeT> skeltree;

<<<<<<< .mine
        void construct_skel(SharedPtr<FunctionImpl<T,D,Pmap> > f) {
            skeltree = SharedPtr<typename DClass<D>::treeT>(new typename DClass<D>::treeT(f->world,
                       f->coeffs.get_mypmap()));
            typename DClass<D>::KeyD root(0);
            madness::print("about to initialize tree");
            if (f->world.mpi.rank() == 0) {
                skeltree->template init_tree<T>(f,root);
            }
            madness::print("just initialized tree");
        };
=======
	void construct_skel(SharedPtr<FunctionImpl<T,D,Pmap> > f) {
	    skeltree = SharedPtr<typename DClass<D>::treeT>(new typename DClass<D>::treeT(f->world,
		f->get_procmap()));
	    typename DClass<D>::KeyD root(0);
	    if (f->world.mpi.rank() == 0) {
	    	skeltree->template init_tree<T>(f,root);
	    }
	};
>>>>>>> .r223

    public:
<<<<<<< .mine
        //Constructors
        LoadBalImpl() {};
=======
	//Constructors
	LoadBalImpl() {};
	LoadBalImpl(Function<T,D,Pmap> f) : f(f) {
	    construct_skel(f.impl);
	};
	~LoadBalImpl() {};
>>>>>>> .r223

        LoadBalImpl(Function<T,D> f) : f(f) {
            madness::print("LoadBalImpl (Function) constructor: f.impl", &f.impl);
            construct_skel(f.impl);
        };

        ~LoadBalImpl() {};

<<<<<<< .mine
        //Methods
        inline void loadBalance() {
            partition(findBestPartition());
        };
=======
	void partition(vector<typename DClass<D>::TreeCoords> v) {
	    // implement partition: copy to new FunctionImpl and replace within f
	    Pmap pmap(f.impl->world, v);
	    SharedPtr<FunctionImpl<T,D,Pmap> > newimpl(new FunctionImpl<T,D,Pmap>(*(f.impl.get()),pmap));
	    if (f.impl->world.mpi.rank() == 0) {
	    	madness::migrate<T,D,Pmap>(f.impl, newimpl);
		Key<D> root(0);
		newimpl->print(root);
	    }
	    f.impl->world.gop.fence();
	    f.impl = newimpl;
	};
>>>>>>> .r223

        vector<typename DClass<D>::TreeCoords> findBestPartition();

        void partition(vector<typename DClass<D>::TreeCoords> v) {
            // implement partition: copy to new FunctionImpl and replace within f
            madness::print("partition: at beginning");
            Pmap pmap(f.impl->world, v);
            SharedPtr<FunctionImpl<T,D,Pmap> > newimpl(new FunctionImpl<T,D>(*(f.impl.get()),pmap)); // ???????????????????????????????????
            if (f.impl->world.mpi.rank() == 0) {
                madness::migrate<T,D,Pmap>(f.impl, newimpl);
            }
            madness::print("partition: at fence");
            f.impl->world.gop.fence();
            madness::print("partition: after fence");
            f.impl = newimpl;
        };

    };

    CompCost computeCompCost(Cost c, int n);

    Cost computePartitionSize(Cost cost, unsigned int parts);

}

#endif


    /// Simple distributed map for the tree
    template <int NDIM>
    class FunctionSimplePmap<NDIM> : public WorldDCPmapInterface< Key<NDIM> > {
    private:
        World* world;
        Level n;

    public:
        FunctionSimplePmap() : world(0), n(2) {};

        FunctionSimplePmap(






// Who knows why these aren't cooperating, so commented out for now
    /*
    template void migrate_data<double,1>(SharedPtr<FunctionImpl<double,1> > tfrom, 
    	SharedPtr<FunctionImpl<double,1> > tto, DClass<1>::KeyD key);
    template void migrate_data<double,2>(SharedPtr<FunctionImpl<double,2> > tfrom, 
    	SharedPtr<FunctionImpl<double,2> > tto, DClass<2>::KeyD key);
    template void migrate_data<double,3>(SharedPtr<FunctionImpl<double,3> > tfrom, 
    	SharedPtr<FunctionImpl<double,3> > tto, DClass<3>::KeyD key);
    template void migrate_data<double,4>(SharedPtr<FunctionImpl<double,4> > tfrom, 
    	SharedPtr<FunctionImpl<double,4> > tto, DClass<4>::KeyD key);
    template void migrate_data<double,5>(SharedPtr<FunctionImpl<double,5> > tfrom, 
    	SharedPtr<FunctionImpl<double,5> > tto, DClass<5>::KeyD key);
    template void migrate_data<double,6>(SharedPtr<FunctionImpl<double,6> > tfrom, 
    	SharedPtr<FunctionImpl<double,6> > tto, DClass<6>::KeyD key);
     
    template void migrate_data<std::complex<double>,1>(SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tto, DClass<1>::KeyD key);
    template void migrate_data<std::complex<double>,2>(SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tto, DClass<2>::KeyD key);
    template void migrate_data<std::complex<double>,3>(SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tto, DClass<3>::KeyD key);
    template void migrate_data<std::complex<double>,4>(SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tto, DClass<4>::KeyD key);
    template void migrate_data<std::complex<double>,5>(SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tto, DClass<5>::KeyD key);
    template void migrate_data<std::complex<double>,6>(SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tto, DClass<6>::KeyD key);
     
    template void migrate<double,1,MyPmap<1> >(SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tfrom, 
    	SharedPtr<FunctionImpl<double,1,MyPmap<1> > > tto);
    template void migrate<double,2,MyPmap<2> >(SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<double,2,MyPmap<2> > > tto);
    template void migrate<double,3,MyPmap<3> >(SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<double,3,MyPmap<3> > > tto);
    template void migrate<double,4,MyPmap<4> >(SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<double,4,MyPmap<4> > > tto);
    template void migrate<double,5,MyPmap<5> >(SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<double,5,MyPmap<5> > > tto);
    template void migrate<double,6,MyPmap<6> >(SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<double,6,MyPmap<6> > > tto);
     
    template void migrate<std::complex<double>,1,MyPmap<1> >(SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,1,MyPmap<1> > > tto);
    template void migrate<std::complex<double>,2,MyPmap<2> >(SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,2,MyPmap<2> > > tto);
    template void migrate<std::complex<double>,3,MyPmap<3> >(SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,3,MyPmap<3> > > tto);
    template void migrate<std::complex<double>,4,MyPmap<4> >(SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,4,MyPmap<4> > > tto);
    template void migrate<std::complex<double>,5,MyPmap<5> >(SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,5,MyPmap<5> > > tto);
    template void migrate<std::complex<double>,6,MyPmap<6> >(SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tfrom, 
    	SharedPtr<FunctionImpl<std::complex<double>,6,MyPmap<6> > > tto);
    */
