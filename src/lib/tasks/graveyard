/// A task with a vector of input and vector of output arguments
template <typename OpT>
class TaskV : public TaskInterface {
private:
    OpT op;
    vector<SAV> inarg;
    vector<SAV> outarg;
public:
	TaskV(OpT op, const vector<SAV> inarg, const vector<SAV> outarg) 
	: op(op)
	, inarg(inarg)
	, outarg(outarg) {};
	
	bool probe() const {
		bool ready = false;
		unsigned n = inarg.size();
		for (unsigned i=0; i<n; i++) 
			ready = ready && inarg[i].probe();
		return ready;
	};
	
	void run() {op(inarg,outarg);};
};


class ManagedDatum {
private:
	int mpi_rank;
public:
	ManagedDatum(int rank = -1) : mpi_rank(rank) {};
	inline int rank() {return mpi_rank;};
};

/// managed_datum_rank returns the MPI rank of managed variables, -1 otherwise
template <class T>
typename enable_if<is_derived_from<T, ManagedDatum>, int>::type 
managed_datum_rank(const T& t) {return t.rank();}

template <class T>
typename enable_if_c<!is_derived_from<T, ManagedDatum>::value,int>::type 
managed_datum_rank(const T& t) {return -1;}

template <typename T>
class MPISAVImpl : public SAVImpl, public ManagedDatum (
public:
	MPISAVImpl() : SAVImpl(), ManagedDatum {};
	
	MPISAVImpl(const T& t) : SAVImpl(t), ManagedDatum(managed_datum_rank(t));
	
	void assign_action() {