#!/usr/bin/env python

# Arguments are a list of process ids ... the collective list of
#  threads in the processes are mapped round robin to the list of
#  cores.

# An effective way to handle multiple MPI processes running an
#  executable named prog.x is
#
#  threadbind `pgrep prog.x`

# If you are really using MPI it may be worth leaving a core free for
#  any additional threads created by MPI/IB etc.  To do this just
#  delete a core from cores[]

import sys,os,subprocess

# Wait for the processes to have created all of their threads
os.system('sleep 1')

# On dual-socket Sandybridge (8 real cores per socket) both of these
# alernating mapping of threads to cores are a lot slower
# ... basically U want threads collaborating on a socket.
#cores = [1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,0]
#cores = [0,1,2,3,  8,9,10,11,  4,5,6,7,  12,13,14,15]

cores = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
ncores = len(cores)

pids = sys.argv[1:]

if len(pids)==1:
    try:
        p = int(pids[0])
    except:
        cmd = "psgrep %s" % pids[0]
        res = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True).strip().split()
        pids[0] = res[0]

core=0
for pid in pids:
    cmd = "ps -mo tid -p %s | egrep -v 'T|-'" % pid
    res = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True).strip().split()
    for tid in res:
        cmd = 'taskset -p -c %d %s >& /dev/null' %(cores[core%ncores], tid)
        if os.system(cmd) != 0:
            print 'failed binding thread',tid
        core = core + 1

