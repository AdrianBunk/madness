#ifndef DFT_H_
#define DFT_H_

#include <mra/mra.h>
#include <world/world.h>
#include <vector>

#include "eigsolver.h"

namespace madness
{
    
  //***************************************************************************
  template <typename T>
  class DFTNuclearPotentialOp : public EigSolverOp<T>
  {
    // Typedef's
    typedef Function<T,3> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFTNuclearPotentialOp(World& world, funcT V, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

  private:
    //*************************************************************************
    funcT _V;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T>
  class DFTCoulombOp : public EigSolverOp<T>
  {
    // Typedef's
    typedef Function<T,3> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFTCoulombOp(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

    //*************************************************************************
    SeparatedConvolution<double,3>* _cop;
    //*************************************************************************

  private:
    //*************************************************************************
    bool _spinpol;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T>
  class DFTCoulombPeriodicOp : public EigSolverOp<T>
  {
    // Typedef's
    typedef Function<T,3> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFTCoulombPeriodicOp(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

    //*************************************************************************
    SeparatedConvolution<double,3>* _cop;
    //*************************************************************************

  private:
    //*************************************************************************
    bool _spinpol;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T>
  class XCFunctionalLDA : public EigSolverOp<T>
  {
    // Typedef's
    typedef Function<T,3> funcT;
  public:
    //*************************************************************************
    // Constructor
    XCFunctionalLDA(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T>
  class DFT : public IEigSolverObserver<T>
  {
    // Typedef's
    typedef Function<T,3> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFT(World& world, funcT V, std::vector<funcT> phis, 
      std::vector<double> eigs, double thresh);
    //*************************************************************************
  
    //*************************************************************************
    // Constructor for ground state only
    DFT(World& world, funcT V, funcT rho, double eig, double thresh);
    //*************************************************************************
  
  	//*************************************************************************
    DFT();
    //*************************************************************************

    //*************************************************************************
    virtual ~DFT();
    //*************************************************************************

    //*************************************************************************
     void solve(int maxits);
     //*************************************************************************
   
     //***************************************************************************
     static double calculate_ke_sp(funcT psi);
     //***************************************************************************

     //***************************************************************************
     static double calculate_tot_ke_sp(const std::vector<funcT>& phis, bool spinpol);
     //***************************************************************************
     
     //***************************************************************************
     static double calculate_tot_pe_sp(const funcT& rho, const funcT V, bool spinpol);
     //***************************************************************************
     
     //***************************************************************************
     static double calculate_tot_coulomb_energy(const funcT& rho, bool spinpol, 
         const World& world, const double thresh);
     //***************************************************************************
     
     //***************************************************************************
     static double calculate_tot_xc_energy(const funcT& rho);
     //***************************************************************************

     //*************************************************************************
     T matrix_element(const funcT& phii, const funcT& phij)
     {
       return _solver->matrix_element(phii, phij);
     }
     //*************************************************************************

     //*************************************************************************
     void print_matrix_elements(const funcT& phii, const funcT& phij)
     {
       _solver->print_matrix_elements(phii, phij);
     }
     //*************************************************************************

     //*************************************************************************
     virtual void iterateOutput(const std::vector<funcT>& phis,
         const std::vector<double>& eigs, const funcT& rho, const int& iter);
     //*************************************************************************

     //*************************************************************************
     double get_eig(int indx)
     {
       return _solver->get_eig(indx);
     }
     //*************************************************************************

     //*************************************************************************
     funcT get_phi(int indx)
     {
       return _solver->get_phi(indx);
     }
     //*************************************************************************
     
     //*************************************************************************
     const std::vector<double>& eigs()
     {
       return _solver->eigs();
     }
     //*************************************************************************

     //*************************************************************************
     const std::vector<funcT>& phis()
     {
       return _solver->phis();
     }
     //*************************************************************************

  private:

      //*************************************************************************
      // Eigenvalue solver
      EigSolver<T>* _solver;
      //*************************************************************************
      
      //*************************************************************************
      World& _world;
      //*************************************************************************

      //*************************************************************************
      funcT _V;
      //*************************************************************************

      //*************************************************************************
      double _thresh;
      //*************************************************************************
      
      //*************************************************************************
      // Exchange-correlation functional. Needed to compute the energy Exc[rho]
      // Gets deleted my the EigSolver class during the EigSolver destructor
      EigSolverOp<T>* _xcfunc;
      //*************************************************************************

      //*************************************************************************
      World& world() {return _world;}
      //*************************************************************************

      //*************************************************************************
      double thresh() {return _thresh;}
      //*************************************************************************

  };
  //***************************************************************************

}
#endif /*DFT_H_*/
