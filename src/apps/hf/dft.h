#ifndef DFT_H_
#define DFT_H_

#include <mra/mra.h>
#include <world/world.h>
#include <vector>

#include "eigsolver.h"

namespace madness
{

  //***************************************************************************
  template <typename T, int NDIM>
  class DFTNuclearPotentialOp : public EigSolverOp<T,NDIM>
  {
  public:
    typedef Function<T,NDIM> funcT;
    //*************************************************************************
    // Constructor
    DFTNuclearPotentialOp(World& world, funcT V, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

  private:
    //*************************************************************************
    funcT _V;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T, int NDIM>
  class DFTCoulombOp : public EigSolverOp<T,NDIM>
  {
    // Typedef's
    typedef Function<T,NDIM> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFTCoulombOp(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

    //*************************************************************************
    // Build the potential from a density if a density-dependent operator.
    virtual void prepare_op(Function<double,NDIM> rho);
    //*************************************************************************

    //*************************************************************************
    SeparatedConvolution<T,NDIM>* _cop;
    //*************************************************************************

  private:
    //*************************************************************************
    funcT _Vc;
    //*************************************************************************

    //*************************************************************************
    bool _spinpol;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T, int NDIM>
  class DFTCoulombPeriodicOp : public EigSolverOp<T,NDIM>
  {
    // Typedef's
    typedef Function<T,NDIM> funcT;
  public:
    //*************************************************************************
    // Constructor
    DFTCoulombPeriodicOp(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************

    //*************************************************************************
    // Build the potential from a density if a density-dependent operator.
    virtual void prepare_op(Function<double,NDIM> rho);
    //*************************************************************************

    //*************************************************************************
    SeparatedConvolution<T,NDIM>* _cop;
    //*************************************************************************

  private:
    //*************************************************************************
    funcT _Vc;
    //*************************************************************************

    //*************************************************************************
    bool _spinpol;
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T, int NDIM>
  class XCFunctionalLDA : public EigSolverOp<T,NDIM>
  {
    // Typedef's
    typedef Function<T,NDIM> funcT;
  public:
    //*************************************************************************
    // Constructor
    XCFunctionalLDA(World& world, double coeff, double thresh);
    //*************************************************************************

    //*************************************************************************
    // Is there an orbitally-dependent term?
    virtual bool is_od() {return false;}
    //*************************************************************************

    //*************************************************************************
    // Is there a density-dependent term?
    virtual bool is_rd() {return true;}
    //*************************************************************************

    //*************************************************************************
    virtual funcT op_r(const funcT& rho, const funcT& psi);
    //*************************************************************************
  };
  //***************************************************************************

  //***************************************************************************
  template <typename T, int NDIM>
  class DFT : public IEigSolverObserver<T,NDIM>
  {
    // Typedef's
    typedef Function<T,NDIM> funcT;
    typedef Vector<double,NDIM> kvecT;
  public:
    //*************************************************************************
    // Constructor
    DFT(World& world, funcT V, std::vector<funcT> phis,
      std::vector<double> eigs, double thresh, bool periodic = false);
    //*************************************************************************

    //*************************************************************************
    // Constructor
    DFT(World& world, funcT V, std::vector<funcT> phis,
      std::vector<double> eigs, std::vector<kvecT> kpoints, double thresh);
    //*************************************************************************

//    //*************************************************************************
//    // Constructor for ground state only
//    DFT(World& world, Function<double,NDIM> V, Function<double,NDIM> rho,
//        double eig, double thresh);
//    //*************************************************************************

  	//*************************************************************************
    DFT();
    //*************************************************************************

    //*************************************************************************
    virtual ~DFT();
    //*************************************************************************

    //*************************************************************************
     void solve(int maxits);
     //*************************************************************************

     //***************************************************************************
     static double calculate_ke_sp(funcT psi, bool periodic = false);
     //***************************************************************************

     //***************************************************************************
     static double calculate_tot_ke_sp(const std::vector<funcT>& phis,
         bool spinpol, bool periodic = false);
     //***************************************************************************

     //***************************************************************************
     static double calculate_tot_pe_sp(const Function<double,NDIM>& rho,
         const funcT V, bool spinpol);
     //***************************************************************************

     //***************************************************************************
     static double calculate_tot_coulomb_energy(const Function<double,NDIM>& rho,
         bool spinpol, const World& world, const double thresh,
         bool periodic = false);
     //***************************************************************************

     //***************************************************************************
     static double calculate_tot_xc_energy(const Function<double,NDIM>& rho);
     //***************************************************************************

     //*************************************************************************
     T matrix_element(const funcT& phii, const funcT& phij)
     {
       return _solver->matrix_element(phii, phij);
     }
     //*************************************************************************

     //*************************************************************************
     void print_matrix_elements(const funcT& phii, const funcT& phij)
     {
       _solver->print_matrix_elements(phii, phij);
     }
     //*************************************************************************

     //*************************************************************************
     virtual void iterateOutput(const std::vector<funcT>& phis,
         const std::vector<double>& eigs, const Function<double,NDIM>& rho,
         const int& iter, bool periodic = false);
     //*************************************************************************

     //*************************************************************************
     double get_eig(int indx)
     {
       return _solver->get_eig(indx);
     }
     //*************************************************************************

     //*************************************************************************
     funcT get_phi(int indx)
     {
       return _solver->get_phi(indx);
     }
     //*************************************************************************

     //*************************************************************************
     const std::vector<double>& eigs()
     {
       return _solver->eigs();
     }
     //*************************************************************************

     //*************************************************************************
     const std::vector<funcT>& phis()
     {
       return _solver->phis();
     }
     //*************************************************************************

  private:

      //*************************************************************************
      // Eigenvalue solver
      EigSolver<T,NDIM>* _solver;
      //*************************************************************************

      //*************************************************************************
      World& _world;
      //*************************************************************************

      //*************************************************************************
      Function<double,NDIM> _V;
      //*************************************************************************

      //*************************************************************************
      double _thresh;
      //*************************************************************************

      //*************************************************************************
      // Exchange-correlation functional. Needed to compute the energy Exc[rho]
      // Gets deleted my the EigSolver class during the EigSolver destructor
      EigSolverOp<T,NDIM>* _xcfunc;
      //*************************************************************************

      //*************************************************************************
      World& world() {return _world;}
      //*************************************************************************

      //*************************************************************************
      double thresh() {return _thresh;}
      //*************************************************************************

  };
  //***************************************************************************

}
#endif /*DFT_H_*/
