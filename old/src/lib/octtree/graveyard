        /// Having a default layout obviates the need for passing the
        /// layout around everywhere or having it as a global variable
        /// (though that is essentially what a static class member
        /// is).  A centralized default also ensures that we are using
        /// the same layout for everything.  Instances can override
        /// the layout which is essential for redistributing data and
        /// more general parallel execution models that might involve
        /// using multiple communicators.
        static inline OctTreeT* get_default() {
            return _octtree_default;
        };

        /// Set the default layout used for new trees

        static shared_ptr<OctTreeT> _octree_default;  ///< Default layout for new trees 

        /// Set the default 
        static inline void set_default(OctTreeT* layout) {
	    _octtree_default = layout;
        };

        /// insert remote parent (x, y, z in {0,1}) returning pointer to parent
        OctTreeT* insert_remote_parent(ProcessID remote_proc) {
            std::cout << "insert_remote_parent: this->(x,y,z) = (" << this->_x << ","
                        << this->_y << "," << this->_z << ")" << std::endl;
            int x = this->_x/2, y = this->_y/2, z = this->_z/2;
            std::cout << "insert_remote_parent: about to insert parent (" << x << ","
                        << y << "," << z << ")" << std::endl;
            _p = SharedPtr<OctTreeT>(new OctTreeT(_n - 1,
                                              x,
                                              y,
                                              z,
                                              true,
                                              0,
                                              remote_proc,
                                              _comm));
/*
            _p = SharedPtr<OctTreeT>(new OctTreeT(_n - 1,
                                              (this->_x)/2,
                                              (this->_y)/2,
                                              (this->_z)/2,
                                              true,
                                              NULL,
                                              remote_proc,
                                              _comm));
*/
            FORIJK(
                _p->_c[i][j][k] = 0;
            );
            _p->setChild(this->_x - ((this->_x)/2)*2,
                         this->_y - ((this->_y)/2)*2,
                         this->_z - ((this->_z)/2)*2,
                         *this);
           _p->_x = x; _p->_y = y; _p->_z = z;
            std::cout << "insert_remote_parent: _p->(x,y,z) = (" << _p->_x << ","
                        << _p->_y << "," << _p->_z << ")" << std::endl;
            return _p;
        };

        
