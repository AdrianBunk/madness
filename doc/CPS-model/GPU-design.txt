CPU-GPU design:

The CPU-GPU interaction is a client-server interaction. The server is the GPU
and it understands a subset of the language that the CPU understands. GPUs
are good at data parallelism, but not at data access, so everything that
the GPU should be concerned about is executing closures.

A closure is made up of a function id and input parameters.  The GPU closures
should be as close to a functional closure as possible, which means they
should be self contained. There should be no entry points for data flow in
the closure, except for the input parameters and parameters from GPU shared
memory.  There should be no output data flow points, except for calls to
update.  These restrictions make sure that there is no inefficient data
access on the GPU.

This way, the only pointers to the CPU process address space are the
method invocations in the update calls. To solve those, the GPU should
keep a hash table that maps WorldContainer , classes and method CPU ids
to GPU ids. The CPU should have both the CPU to GPU and the GPU to CPU ids
maps.

All needed WorldContainers, classes and methods will be registered to these
maps both on the CPU and the GPU. When the CPU sends a closure to the GPU, it
replaces, within that closure, the method invocation with the respective id.
That id corresponds to an equivalent function on the GPU, that takes as input
the parameters from the closure. The CPU keeps output buffers  per class and
method (closure) and sends them when they fill up or on synchronization to
the GPU. The GPU looks up the method id in the buffer (the method is the same
for all closures in the buffer), obtains the corresponding function from GPU
address space and initiates a Map of the function over the data in the
closures.  The GPUs have output buffers per container id per class and method
for the updates generated by executing the closures. When buffers fill or on
sync, it is sent to the CPU, where updates are resolved to pointers. 

Note that all updates begin execution on the CPU.  An update will be
implemented in two parts: the first part is data access on the CPUs in which
all data is accessed and added to the closure, while the second part is
closure execution on the GPU.

GPU equivalents of CPU methods:

Two major possibilities:
- actual slightly modified classes and methods
- C equivalent functions (tricky)

The update calls within the GPU need to be modified:
either pass WorldContainer ids and method ids as parameters
or use some template mechanism to replace them in the function body.
