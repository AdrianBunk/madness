high-level design & associated containers

- one motivication for using threads, not shmem, was better
cache-ability of data and direct sharing of data structures, including
the ability to operate on the stored copies eliminating any
(de)serialization costs.

- so the high-level container should permit local threads to operate
inplace.

- think of a shared-container not a shared object model ... though we
want a path to distributed objects beyond those of global arrays

- the only thing in a shared-container are single process objects

- we want to bound memory use without relying upon virtual memory (not
always available and without loop tiling not efficient)

- if the loops acessing the functions are tiled, we can keep functions
in a cache, and only write them to disk when short of memory.
However, we need to keep track of which ones are being used, and which
ones not ... reference counting and no unshared pointers.

- we want a consistent and intuitive model ... and ideally
a familiar one

- remote parallel access needs to be done without incrementing
reference counts.

- iterators over the container can do most of what we need
   o for_each() ... parallel execution with option of 
     dynamic load balancing ... but could initially resolve
     into just calling
   o for_each_local() ... iterate over items local to 
     invoking process
   o for_each_pair() ... tiled for memory locality


Mostly separate from the above we have to thing about serialization.

- to files
- to memory resident buffers
- to send data between processes using messages
- to send directly to remote memory using one-sided access

- want this to happen efficiently ... template a stream
class so that operations can be inlined at compile time.
The alternative of using virual functions in a base 
class precludes inlining.

- files and messaging will use memory buffers as a cache 
... just need to redefine the flush() and buffer_full()
actions ... can add zero copy operations as an 
optimizaiton.



